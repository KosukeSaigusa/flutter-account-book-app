// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'models.dart';

// **************************************************************************
// SqfEntityGenerator
// **************************************************************************

//  These classes was generated by SqfEntity
//  Copyright (c) 2019, All rights reserved. Use of this source code is governed by a
//  Apache license that can be found in the LICENSE file.

//  To use these SqfEntity classes do following:
//  - import model.dart into where to use
//  - start typing ex:Expense.select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
//  - and then just put end of filters / or end of only select()  toSingle() / or toList()
//  - you can select one or return List<yourObject> by your filters and orders
//  - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
//    Enjoy.. Huseyin Tokpunar

// ignore_for_file:
// BEGIN TABLES
// Expense TABLE
class TableExpense extends SqfEntityTableBase {
  TableExpense() {
    // declare properties of EntityTable
    tableName = 'expense';
    primaryKeyName = 'expense_id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('note', DbType.text, isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableExpenseCategory.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'expense_category_id',
          isNotNull: false),
      SqfEntityFieldBase('price', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('satisfaction', DbType.integer,
          defaultValue: 3, isNotNull: false, minValue: 1, maxValue: 5),
      SqfEntityFieldBase('year', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('month', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('date', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('created_at', DbType.datetime,
          isNotNull: false, minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableExpense();
  }
}

// Income TABLE
class TableIncome extends SqfEntityTableBase {
  TableIncome() {
    // declare properties of EntityTable
    tableName = 'income';
    primaryKeyName = 'income_id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('note', DbType.text, isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableIncomeCategory.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'income_category_id',
          isNotNull: false),
      SqfEntityFieldBase('price', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('year', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('month', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('date', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('created_at', DbType.datetime,
          isNotNull: false, minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableIncome();
  }
}

// ExpenseCategory TABLE
class TableExpenseCategory extends SqfEntityTableBase {
  TableExpenseCategory() {
    // declare properties of EntityTable
    tableName = 'expensecategory';
    primaryKeyName = 'expense_category_id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text, isNotNull: false),
      SqfEntityFieldBase('budget', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('priority', DbType.integer, isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableAppIcon.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'icon_id',
          isNotNull: false),
      SqfEntityFieldBase('created_at', DbType.datetime,
          isNotNull: false, minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableExpenseCategory();
  }
}

// IncomeCategory TABLE
class TableIncomeCategory extends SqfEntityTableBase {
  TableIncomeCategory() {
    // declare properties of EntityTable
    tableName = 'incomecategory';
    primaryKeyName = 'income_category_id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text, isNotNull: false),
      SqfEntityFieldBase('priority', DbType.integer, isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableAppIcon.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'icon_id',
          isNotNull: false),
      SqfEntityFieldBase('created_at', DbType.datetime,
          isNotNull: false, minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableIncomeCategory();
  }
}

// FixedFee TABLE
class TableFixedFee extends SqfEntityTableBase {
  TableFixedFee() {
    // declare properties of EntityTable
    tableName = 'fixedfee';
    primaryKeyName = 'fixed_fee_id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text, isNotNull: false),
      SqfEntityFieldBase('price', DbType.integer, isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TablePaymentCycle.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'payment_cycle_id',
          isNotNull: false),
      SqfEntityFieldBase('note', DbType.text, isNotNull: false),
      SqfEntityFieldBase('priority', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('created_at', DbType.datetime,
          isNotNull: false, minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableFixedFee();
  }
}

// AppIcon TABLE
class TableAppIcon extends SqfEntityTableBase {
  TableAppIcon() {
    // declare properties of EntityTable
    tableName = 'icon';
    primaryKeyName = 'icon_id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text, isNotNull: false),
      SqfEntityFieldBase('priority', DbType.integer, isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableAppIcon();
  }
}

// PaymentCycle TABLE
class TablePaymentCycle extends SqfEntityTableBase {
  TablePaymentCycle() {
    // declare properties of EntityTable
    tableName = 'paymentcycle';
    primaryKeyName = 'payment_cycle_id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('month', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('priority', DbType.integer, isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TablePaymentCycle();
  }
}
// END TABLES

// BEGIN DATABASE MODEL
class DbModel extends SqfEntityModelProvider {
  DbModel() {
    databaseName = dbModel.databaseName;
    password = dbModel.password;
    dbVersion = dbModel.dbVersion;
    databaseTables = [
      TableExpense.getInstance,
      TableIncome.getInstance,
      TableExpenseCategory.getInstance,
      TableIncomeCategory.getInstance,
      TableFixedFee.getInstance,
      TableAppIcon.getInstance,
      TablePaymentCycle.getInstance,
    ];

    bundledDatabasePath = dbModel
        .bundledDatabasePath; //'assets/sample.db'; // This value is optional. When bundledDatabasePath is empty then EntityBase creats a new database when initializing the database
  }
  Map<String, dynamic> getControllers() {
    final controllers = <String, dynamic>{};

    return controllers;
  }
}
// END DATABASE MODEL

// BEGIN ENTITIES
// region Expense
class Expense {
  Expense(
      {this.expense_id,
      this.note,
      this.expense_category_id,
      this.price,
      this.satisfaction,
      this.year,
      this.month,
      this.date,
      this.created_at}) {
    _setDefaultValues();
  }
  Expense.withFields(this.note, this.expense_category_id, this.price,
      this.satisfaction, this.year, this.month, this.date, this.created_at) {
    _setDefaultValues();
  }
  Expense.withId(
      this.expense_id,
      this.note,
      this.expense_category_id,
      this.price,
      this.satisfaction,
      this.year,
      this.month,
      this.date,
      this.created_at) {
    _setDefaultValues();
  }
  Expense.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    expense_id = int.tryParse(o['expense_id'].toString());
    if (o['note'] != null) {
      note = o['note'] as String;
    }
    expense_category_id = int.tryParse(o['expense_category_id'].toString());

    if (o['price'] != null) {
      price = int.tryParse(o['price'].toString());
    }
    if (o['satisfaction'] != null) {
      satisfaction = int.tryParse(o['satisfaction'].toString());
    }
    if (o['year'] != null) {
      year = int.tryParse(o['year'].toString());
    }
    if (o['month'] != null) {
      month = int.tryParse(o['month'].toString());
    }
    if (o['date'] != null) {
      date = int.tryParse(o['date'].toString());
    }
    if (o['created_at'] != null) {
      created_at = int.tryParse(o['created_at'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['created_at'].toString()))
          : DateTime.tryParse(o['created_at'].toString());
    }

    // RELATIONSHIPS FromMAP
    plExpenseCategory = o['expenseCategory'] != null
        ? ExpenseCategory.fromMap(o['expenseCategory'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (Expense)
  int expense_id;
  String note;
  int expense_category_id;
  int price;
  int satisfaction;
  int year;
  int month;
  int date;
  DateTime created_at;

  BoolResult saveResult;
  // end FIELDS (Expense)

// RELATIONSHIPS (Expense)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plExpenseCategory', 'plField2'..]) or so on..
  ExpenseCategory plExpenseCategory;

  /// get ExpenseCategory By Expense_category_id
  Future<ExpenseCategory> getExpenseCategory(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await ExpenseCategory().getById(expense_category_id,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Expense)

  static const bool _softDeleteActivated = false;
  ExpenseManager __mnExpense;

  ExpenseManager get _mnExpense {
    return __mnExpense = __mnExpense ?? ExpenseManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (expense_id != null) {
      map['expense_id'] = expense_id;
    }
    if (note != null) {
      map['note'] = note;
    }

    if (expense_category_id != null) {
      map['expense_category_id'] =
          forView ? plExpenseCategory.name : expense_category_id;
    }

    if (price != null) {
      map['price'] = price;
    }

    if (satisfaction != null) {
      map['satisfaction'] = satisfaction;
    }

    if (year != null) {
      map['year'] = year;
    }

    if (month != null) {
      map['month'] = month;
    }

    if (date != null) {
      map['date'] = date;
    }

    if (created_at != null) {
      map['created_at'] = forJson
          ? created_at.toString()
          : forQuery
              ? created_at.millisecondsSinceEpoch
              : created_at;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (expense_id != null) {
      map['expense_id'] = expense_id;
    }
    if (note != null) {
      map['note'] = note;
    }

    if (expense_category_id != null) {
      map['expense_category_id'] =
          forView ? plExpenseCategory.name : expense_category_id;
    }

    if (price != null) {
      map['price'] = price;
    }

    if (satisfaction != null) {
      map['satisfaction'] = satisfaction;
    }

    if (year != null) {
      map['year'] = year;
    }

    if (month != null) {
      map['month'] = month;
    }

    if (date != null) {
      map['date'] = date;
    }

    if (created_at != null) {
      map['created_at'] = forJson
          ? created_at.toString()
          : forQuery
              ? created_at.millisecondsSinceEpoch
              : created_at;
    }

    return map;
  }

  /// This method returns Json String [Expense]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Expense]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      note,
      expense_category_id,
      price,
      satisfaction,
      year,
      month,
      date,
      created_at != null ? created_at.millisecondsSinceEpoch : null
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      expense_id,
      note,
      expense_category_id,
      price,
      satisfaction,
      year,
      month,
      date,
      created_at != null ? created_at.millisecondsSinceEpoch : null
    ];
  }

  static Future<List<Expense>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR Expense.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<Expense>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Expense>[];
    try {
      objList = list
          .map((expense) => Expense.fromMap(expense as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print('SQFENTITY ERROR Expense.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Expense>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<Expense> objList = <Expense>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Expense.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('expensecategory.plExpenseCategory') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plExpenseCategory'))) {
          /*_loadedFields.add('expensecategory.plExpenseCategory');*/
          obj.plExpenseCategory = obj.plExpenseCategory ??
              await obj.getExpenseCategory(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Expense by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int expense_id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns Expense if exist, otherwise returns null
  Future<Expense> getById(int expense_id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (expense_id == null) {
      return null;
    }
    Expense obj;
    final data = await _mnExpense.getById([expense_id]);
    if (data.length != 0) {
      obj = Expense.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('expensecategory.plExpenseCategory') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plExpenseCategory'))) {
          /*_loadedFields.add('expensecategory.plExpenseCategory');*/
          obj.plExpenseCategory = obj.plExpenseCategory ??
              await obj.getExpenseCategory(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Expense) object. If the expense_id field is null, saves as a new record and returns new expense_id, if expense_id is not null then updates record

  /// <returns>Returns expense_id
  Future<int> save() async {
    if (expense_id == null || expense_id == 0) {
      expense_id = await _mnExpense.insert(this);
    } else {
      // expense_id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnExpense.update(this);
    }

    return expense_id;
  }

  /// saveAs Expense. Returns a new Primary Key value of Expense

  /// <returns>Returns a new Primary Key value of Expense
  Future<int> saveAs() async {
    expense_id = null;

    return save();
  }

  /// saveAll method saves the sent List<Expense> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Expense> expenses) async {
    // final results = _mnExpense.saveAll('INSERT OR REPLACE INTO expense (expense_id,note, expense_category_id, price, satisfaction, year, month, date, created_at)  VALUES (?,?,?,?,?,?,?,?,?)',expenses);
    // return results; removed in sqfentity_gen 1.3.0+6
    await DbModel().batchStart();
    for (final obj in expenses) {
      await obj.save();
    }
    //    return DbModel().batchCommit();
    final result = await DbModel().batchCommit();
    for (int i = 0; i < expenses.length; i++) {
      if (expenses[i].expense_id == null) {
        expenses[i].expense_id = result[i] as int;
      }
    }

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns expense_id
  Future<int> upsert() async {
    try {
      if (await _mnExpense.rawInsert(
              'INSERT OR REPLACE INTO expense (expense_id,note, expense_category_id, price, satisfaction, year, month, date, created_at)  VALUES (?,?,?,?,?,?,?,?,?)',
              [
                expense_id,
                note,
                expense_category_id,
                price,
                satisfaction,
                year,
                month,
                date,
                created_at != null ? created_at.millisecondsSinceEpoch : null
              ]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Expense expense_id=$expense_id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Expense expense_id=$expense_id did not update');
      }
      return expense_id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Expense Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<Expense>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<Expense> expenses) async {
    final results = await _mnExpense.rawInsertAll(
        'INSERT OR REPLACE INTO expense (expense_id,note, expense_category_id, price, satisfaction, year, month, date, created_at)  VALUES (?,?,?,?,?,?,?,?,?)',
        expenses);
    return results;
  }

  /// Deletes Expense

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete Expense invoked (expense_id=$expense_id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnExpense.delete(QueryParams(
          whereString: 'expense_id=?', whereArguments: [expense_id]));
    } else {
      return _mnExpense.updateBatch(
          QueryParams(
              whereString: 'expense_id=?', whereArguments: [expense_id]),
          {'isDeleted': 1});
    }
  }

  ExpenseFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return ExpenseFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  ExpenseFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return ExpenseFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    satisfaction = satisfaction ?? 3;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion expense

// region ExpenseField
class ExpenseField extends SearchCriteria {
  ExpenseField(this.expenseFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  ExpenseFilterBuilder expenseFB;

  ExpenseField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  ExpenseFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    expenseFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, expenseFB.parameters, param, SqlSyntax.EQuals,
            expenseFB._addedBlocks)
        : setCriteria(pValue, expenseFB.parameters, param, SqlSyntax.NotEQuals,
            expenseFB._addedBlocks);
    _waitingNot = '';
    expenseFB._addedBlocks.needEndBlock[expenseFB._blockIndex] =
        expenseFB._addedBlocks.retVal;
    return expenseFB;
  }

  ExpenseFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    expenseFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, expenseFB.parameters, param,
            SqlSyntax.EQualsOrNull, expenseFB._addedBlocks)
        : setCriteria(pValue, expenseFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, expenseFB._addedBlocks);
    _waitingNot = '';
    expenseFB._addedBlocks.needEndBlock[expenseFB._blockIndex] =
        expenseFB._addedBlocks.retVal;
    return expenseFB;
  }

  ExpenseFilterBuilder isNull() {
    expenseFB._addedBlocks = setCriteria(
        0,
        expenseFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        expenseFB._addedBlocks);
    _waitingNot = '';
    expenseFB._addedBlocks.needEndBlock[expenseFB._blockIndex] =
        expenseFB._addedBlocks.retVal;
    return expenseFB;
  }

  ExpenseFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      expenseFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          expenseFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          expenseFB._addedBlocks);
      _waitingNot = '';
      expenseFB._addedBlocks.needEndBlock[expenseFB._blockIndex] =
          expenseFB._addedBlocks.retVal;
    }
    return expenseFB;
  }

  ExpenseFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      expenseFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          expenseFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          expenseFB._addedBlocks);
      _waitingNot = '';
      expenseFB._addedBlocks.needEndBlock[expenseFB._blockIndex] =
          expenseFB._addedBlocks.retVal;
      expenseFB._addedBlocks.needEndBlock[expenseFB._blockIndex] =
          expenseFB._addedBlocks.retVal;
    }
    return expenseFB;
  }

  ExpenseFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      expenseFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          expenseFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          expenseFB._addedBlocks);
      _waitingNot = '';
      expenseFB._addedBlocks.needEndBlock[expenseFB._blockIndex] =
          expenseFB._addedBlocks.retVal;
    }
    return expenseFB;
  }

  ExpenseFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      expenseFB._addedBlocks = setCriteria(
          pFirst,
          expenseFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          expenseFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        expenseFB._addedBlocks = setCriteria(pFirst, expenseFB.parameters,
            param, SqlSyntax.LessThan, expenseFB._addedBlocks);
      } else {
        expenseFB._addedBlocks = setCriteria(pFirst, expenseFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, expenseFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        expenseFB._addedBlocks = setCriteria(pLast, expenseFB.parameters, param,
            SqlSyntax.GreaterThan, expenseFB._addedBlocks);
      } else {
        expenseFB._addedBlocks = setCriteria(pLast, expenseFB.parameters, param,
            SqlSyntax.LessThanOrEquals, expenseFB._addedBlocks);
      }
    }
    _waitingNot = '';
    expenseFB._addedBlocks.needEndBlock[expenseFB._blockIndex] =
        expenseFB._addedBlocks.retVal;
    return expenseFB;
  }

  ExpenseFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    expenseFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, expenseFB.parameters, param,
            SqlSyntax.GreaterThan, expenseFB._addedBlocks)
        : setCriteria(pValue, expenseFB.parameters, param,
            SqlSyntax.LessThanOrEquals, expenseFB._addedBlocks);
    _waitingNot = '';
    expenseFB._addedBlocks.needEndBlock[expenseFB._blockIndex] =
        expenseFB._addedBlocks.retVal;
    return expenseFB;
  }

  ExpenseFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    expenseFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, expenseFB.parameters, param, SqlSyntax.LessThan,
            expenseFB._addedBlocks)
        : setCriteria(pValue, expenseFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, expenseFB._addedBlocks);
    _waitingNot = '';
    expenseFB._addedBlocks.needEndBlock[expenseFB._blockIndex] =
        expenseFB._addedBlocks.retVal;
    return expenseFB;
  }

  ExpenseFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    expenseFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, expenseFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, expenseFB._addedBlocks)
        : setCriteria(pValue, expenseFB.parameters, param, SqlSyntax.LessThan,
            expenseFB._addedBlocks);
    _waitingNot = '';
    expenseFB._addedBlocks.needEndBlock[expenseFB._blockIndex] =
        expenseFB._addedBlocks.retVal;
    return expenseFB;
  }

  ExpenseFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    expenseFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, expenseFB.parameters, param,
            SqlSyntax.LessThanOrEquals, expenseFB._addedBlocks)
        : setCriteria(pValue, expenseFB.parameters, param,
            SqlSyntax.GreaterThan, expenseFB._addedBlocks);
    _waitingNot = '';
    expenseFB._addedBlocks.needEndBlock[expenseFB._blockIndex] =
        expenseFB._addedBlocks.retVal;
    return expenseFB;
  }

  ExpenseFilterBuilder inValues(dynamic pValue) {
    expenseFB._addedBlocks = setCriteria(
        pValue,
        expenseFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        expenseFB._addedBlocks);
    _waitingNot = '';
    expenseFB._addedBlocks.needEndBlock[expenseFB._blockIndex] =
        expenseFB._addedBlocks.retVal;
    return expenseFB;
  }
}
// endregion ExpenseField

// region ExpenseFilterBuilder
class ExpenseFilterBuilder extends SearchCriteria {
  ExpenseFilterBuilder(Expense obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  Expense _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  ExpenseFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  ExpenseFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  ExpenseFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  ExpenseFilterBuilder where(String whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  ExpenseFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  ExpenseFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  ExpenseFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  ExpenseFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  ExpenseFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  ExpenseFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  ExpenseFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  ExpenseField setField(ExpenseField field, String colName, DbType dbtype) {
    return ExpenseField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  ExpenseField _expense_id;
  ExpenseField get expense_id {
    return _expense_id = setField(_expense_id, 'expense_id', DbType.integer);
  }

  ExpenseField _note;
  ExpenseField get note {
    return _note = setField(_note, 'note', DbType.text);
  }

  ExpenseField _expense_category_id;
  ExpenseField get expense_category_id {
    return _expense_category_id =
        setField(_expense_category_id, 'expense_category_id', DbType.integer);
  }

  ExpenseField _price;
  ExpenseField get price {
    return _price = setField(_price, 'price', DbType.integer);
  }

  ExpenseField _satisfaction;
  ExpenseField get satisfaction {
    return _satisfaction =
        setField(_satisfaction, 'satisfaction', DbType.integer);
  }

  ExpenseField _year;
  ExpenseField get year {
    return _year = setField(_year, 'year', DbType.integer);
  }

  ExpenseField _month;
  ExpenseField get month {
    return _month = setField(_month, 'month', DbType.integer);
  }

  ExpenseField _date;
  ExpenseField get date {
    return _date = setField(_date, 'date', DbType.integer);
  }

  ExpenseField _created_at;
  ExpenseField get created_at {
    return _created_at = setField(_created_at, 'created_at', DbType.datetime);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (Expense._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<Expense> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();

    if (Expense._softDeleteActivated && !hardDelete) {
      r = await _obj._mnExpense.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnExpense.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'expense_id IN (SELECT expense_id from expense ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnExpense.updateBatch(qparams, values);
  }

  /// This method always returns Expense Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Expense>
  Future<Expense> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnExpense.toList(qparams);
    final data = await objFuture;
    Expense obj;
    if (data.isNotEmpty) {
      obj = Expense.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('expensecategory.plExpenseCategory') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plExpenseCategory'))) {
          /*_loadedFields.add('expensecategory.plExpenseCategory');*/
          obj.plExpenseCategory = obj.plExpenseCategory ??
              await obj.getExpenseCategory(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [Expense]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) expenseCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final expensesFuture = await _obj._mnExpense.toList(qparams);
    final int count = expensesFuture[0]['CNT'] as int;
    if (expenseCount != null) {
      expenseCount(count);
    }
    return count;
  }

  /// This method returns List<Expense> [Expense]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Expense>
  Future<List<Expense>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<Expense> expensesData = await Expense.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return expensesData;
  }

  /// This method returns Json String [Expense]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Expense]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Expense]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnExpense.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Expense]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `expense_id` FROM expense WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> expense_idData = <int>[];
    qparams.selectColumns = ['expense_id'];
    final expense_idFuture = await _obj._mnExpense.toList(qparams);

    final int count = expense_idFuture.length;
    for (int i = 0; i < count; i++) {
      expense_idData.add(expense_idFuture[i]['expense_id'] as int);
    }
    return expense_idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Expense]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnExpense.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await Expense.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnExpense.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ExpenseFilterBuilder

// region ExpenseFields
class ExpenseFields {
  static TableField _fExpense_id;
  static TableField get expense_id {
    return _fExpense_id = _fExpense_id ??
        SqlSyntax.setField(_fExpense_id, 'expense_id', DbType.integer);
  }

  static TableField _fNote;
  static TableField get note {
    return _fNote = _fNote ?? SqlSyntax.setField(_fNote, 'note', DbType.text);
  }

  static TableField _fExpense_category_id;
  static TableField get expense_category_id {
    return _fExpense_category_id = _fExpense_category_id ??
        SqlSyntax.setField(
            _fExpense_category_id, 'expense_category_id', DbType.integer);
  }

  static TableField _fPrice;
  static TableField get price {
    return _fPrice =
        _fPrice ?? SqlSyntax.setField(_fPrice, 'price', DbType.integer);
  }

  static TableField _fSatisfaction;
  static TableField get satisfaction {
    return _fSatisfaction = _fSatisfaction ??
        SqlSyntax.setField(_fSatisfaction, 'satisfaction', DbType.integer);
  }

  static TableField _fYear;
  static TableField get year {
    return _fYear =
        _fYear ?? SqlSyntax.setField(_fYear, 'year', DbType.integer);
  }

  static TableField _fMonth;
  static TableField get month {
    return _fMonth =
        _fMonth ?? SqlSyntax.setField(_fMonth, 'month', DbType.integer);
  }

  static TableField _fDate;
  static TableField get date {
    return _fDate =
        _fDate ?? SqlSyntax.setField(_fDate, 'date', DbType.integer);
  }

  static TableField _fCreated_at;
  static TableField get created_at {
    return _fCreated_at = _fCreated_at ??
        SqlSyntax.setField(_fCreated_at, 'created_at', DbType.datetime);
  }
}
// endregion ExpenseFields

//region ExpenseManager
class ExpenseManager extends SqfEntityProvider {
  ExpenseManager()
      : super(DbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'expense';
  static final List<String> _primaryKeyList = ['expense_id'];
  static final String _whereStr = 'expense_id=?';
}

//endregion ExpenseManager
// region Income
class Income {
  Income(
      {this.income_id,
      this.note,
      this.income_category_id,
      this.price,
      this.year,
      this.month,
      this.date,
      this.created_at}) {
    _setDefaultValues();
  }
  Income.withFields(this.note, this.income_category_id, this.price, this.year,
      this.month, this.date, this.created_at) {
    _setDefaultValues();
  }
  Income.withId(this.income_id, this.note, this.income_category_id, this.price,
      this.year, this.month, this.date, this.created_at) {
    _setDefaultValues();
  }
  Income.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    income_id = int.tryParse(o['income_id'].toString());
    if (o['note'] != null) {
      note = o['note'] as String;
    }
    income_category_id = int.tryParse(o['income_category_id'].toString());

    if (o['price'] != null) {
      price = int.tryParse(o['price'].toString());
    }
    if (o['year'] != null) {
      year = int.tryParse(o['year'].toString());
    }
    if (o['month'] != null) {
      month = int.tryParse(o['month'].toString());
    }
    if (o['date'] != null) {
      date = int.tryParse(o['date'].toString());
    }
    if (o['created_at'] != null) {
      created_at = int.tryParse(o['created_at'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['created_at'].toString()))
          : DateTime.tryParse(o['created_at'].toString());
    }

    // RELATIONSHIPS FromMAP
    plIncomeCategory = o['incomeCategory'] != null
        ? IncomeCategory.fromMap(o['incomeCategory'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (Income)
  int income_id;
  String note;
  int income_category_id;
  int price;
  int year;
  int month;
  int date;
  DateTime created_at;

  BoolResult saveResult;
  // end FIELDS (Income)

// RELATIONSHIPS (Income)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plIncomeCategory', 'plField2'..]) or so on..
  IncomeCategory plIncomeCategory;

  /// get IncomeCategory By Income_category_id
  Future<IncomeCategory> getIncomeCategory(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await IncomeCategory().getById(income_category_id,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Income)

  static const bool _softDeleteActivated = false;
  IncomeManager __mnIncome;

  IncomeManager get _mnIncome {
    return __mnIncome = __mnIncome ?? IncomeManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (income_id != null) {
      map['income_id'] = income_id;
    }
    if (note != null) {
      map['note'] = note;
    }

    if (income_category_id != null) {
      map['income_category_id'] =
          forView ? plIncomeCategory.name : income_category_id;
    }

    if (price != null) {
      map['price'] = price;
    }

    if (year != null) {
      map['year'] = year;
    }

    if (month != null) {
      map['month'] = month;
    }

    if (date != null) {
      map['date'] = date;
    }

    if (created_at != null) {
      map['created_at'] = forJson
          ? created_at.toString()
          : forQuery
              ? created_at.millisecondsSinceEpoch
              : created_at;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (income_id != null) {
      map['income_id'] = income_id;
    }
    if (note != null) {
      map['note'] = note;
    }

    if (income_category_id != null) {
      map['income_category_id'] =
          forView ? plIncomeCategory.name : income_category_id;
    }

    if (price != null) {
      map['price'] = price;
    }

    if (year != null) {
      map['year'] = year;
    }

    if (month != null) {
      map['month'] = month;
    }

    if (date != null) {
      map['date'] = date;
    }

    if (created_at != null) {
      map['created_at'] = forJson
          ? created_at.toString()
          : forQuery
              ? created_at.millisecondsSinceEpoch
              : created_at;
    }

    return map;
  }

  /// This method returns Json String [Income]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Income]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      note,
      income_category_id,
      price,
      year,
      month,
      date,
      created_at != null ? created_at.millisecondsSinceEpoch : null
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      income_id,
      note,
      income_category_id,
      price,
      year,
      month,
      date,
      created_at != null ? created_at.millisecondsSinceEpoch : null
    ];
  }

  static Future<List<Income>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print('SQFENTITY ERROR Income.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<Income>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Income>[];
    try {
      objList = list
          .map((income) => Income.fromMap(income as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print('SQFENTITY ERROR Income.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Income>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<Income> objList = <Income>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Income.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('incomecategory.plIncomeCategory') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plIncomeCategory'))) {
          /*_loadedFields.add('incomecategory.plIncomeCategory');*/
          obj.plIncomeCategory = obj.plIncomeCategory ??
              await obj.getIncomeCategory(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Income by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int income_id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns Income if exist, otherwise returns null
  Future<Income> getById(int income_id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (income_id == null) {
      return null;
    }
    Income obj;
    final data = await _mnIncome.getById([income_id]);
    if (data.length != 0) {
      obj = Income.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('incomecategory.plIncomeCategory') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plIncomeCategory'))) {
          /*_loadedFields.add('incomecategory.plIncomeCategory');*/
          obj.plIncomeCategory = obj.plIncomeCategory ??
              await obj.getIncomeCategory(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Income) object. If the income_id field is null, saves as a new record and returns new income_id, if income_id is not null then updates record

  /// <returns>Returns income_id
  Future<int> save() async {
    if (income_id == null || income_id == 0) {
      income_id = await _mnIncome.insert(this);
    } else {
      // income_id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnIncome.update(this);
    }

    return income_id;
  }

  /// saveAs Income. Returns a new Primary Key value of Income

  /// <returns>Returns a new Primary Key value of Income
  Future<int> saveAs() async {
    income_id = null;

    return save();
  }

  /// saveAll method saves the sent List<Income> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Income> incomes) async {
    // final results = _mnIncome.saveAll('INSERT OR REPLACE INTO income (income_id,note, income_category_id, price, year, month, date, created_at)  VALUES (?,?,?,?,?,?,?,?)',incomes);
    // return results; removed in sqfentity_gen 1.3.0+6
    await DbModel().batchStart();
    for (final obj in incomes) {
      await obj.save();
    }
    //    return DbModel().batchCommit();
    final result = await DbModel().batchCommit();
    for (int i = 0; i < incomes.length; i++) {
      if (incomes[i].income_id == null) {
        incomes[i].income_id = result[i] as int;
      }
    }

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns income_id
  Future<int> upsert() async {
    try {
      if (await _mnIncome.rawInsert(
              'INSERT OR REPLACE INTO income (income_id,note, income_category_id, price, year, month, date, created_at)  VALUES (?,?,?,?,?,?,?,?)',
              [
                income_id,
                note,
                income_category_id,
                price,
                year,
                month,
                date,
                created_at != null ? created_at.millisecondsSinceEpoch : null
              ]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Income income_id=$income_id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Income income_id=$income_id did not update');
      }
      return income_id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Income Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<Income>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<Income> incomes) async {
    final results = await _mnIncome.rawInsertAll(
        'INSERT OR REPLACE INTO income (income_id,note, income_category_id, price, year, month, date, created_at)  VALUES (?,?,?,?,?,?,?,?)',
        incomes);
    return results;
  }

  /// Deletes Income

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete Income invoked (income_id=$income_id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnIncome.delete(
          QueryParams(whereString: 'income_id=?', whereArguments: [income_id]));
    } else {
      return _mnIncome.updateBatch(
          QueryParams(whereString: 'income_id=?', whereArguments: [income_id]),
          {'isDeleted': 1});
    }
  }

  IncomeFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return IncomeFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  IncomeFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return IncomeFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion income

// region IncomeField
class IncomeField extends SearchCriteria {
  IncomeField(this.incomeFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  IncomeFilterBuilder incomeFB;

  IncomeField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  IncomeFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    incomeFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, incomeFB.parameters, param, SqlSyntax.EQuals,
            incomeFB._addedBlocks)
        : setCriteria(pValue, incomeFB.parameters, param, SqlSyntax.NotEQuals,
            incomeFB._addedBlocks);
    _waitingNot = '';
    incomeFB._addedBlocks.needEndBlock[incomeFB._blockIndex] =
        incomeFB._addedBlocks.retVal;
    return incomeFB;
  }

  IncomeFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    incomeFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, incomeFB.parameters, param,
            SqlSyntax.EQualsOrNull, incomeFB._addedBlocks)
        : setCriteria(pValue, incomeFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, incomeFB._addedBlocks);
    _waitingNot = '';
    incomeFB._addedBlocks.needEndBlock[incomeFB._blockIndex] =
        incomeFB._addedBlocks.retVal;
    return incomeFB;
  }

  IncomeFilterBuilder isNull() {
    incomeFB._addedBlocks = setCriteria(
        0,
        incomeFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        incomeFB._addedBlocks);
    _waitingNot = '';
    incomeFB._addedBlocks.needEndBlock[incomeFB._blockIndex] =
        incomeFB._addedBlocks.retVal;
    return incomeFB;
  }

  IncomeFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      incomeFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          incomeFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          incomeFB._addedBlocks);
      _waitingNot = '';
      incomeFB._addedBlocks.needEndBlock[incomeFB._blockIndex] =
          incomeFB._addedBlocks.retVal;
    }
    return incomeFB;
  }

  IncomeFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      incomeFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          incomeFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          incomeFB._addedBlocks);
      _waitingNot = '';
      incomeFB._addedBlocks.needEndBlock[incomeFB._blockIndex] =
          incomeFB._addedBlocks.retVal;
      incomeFB._addedBlocks.needEndBlock[incomeFB._blockIndex] =
          incomeFB._addedBlocks.retVal;
    }
    return incomeFB;
  }

  IncomeFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      incomeFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          incomeFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          incomeFB._addedBlocks);
      _waitingNot = '';
      incomeFB._addedBlocks.needEndBlock[incomeFB._blockIndex] =
          incomeFB._addedBlocks.retVal;
    }
    return incomeFB;
  }

  IncomeFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      incomeFB._addedBlocks = setCriteria(
          pFirst,
          incomeFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          incomeFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        incomeFB._addedBlocks = setCriteria(pFirst, incomeFB.parameters, param,
            SqlSyntax.LessThan, incomeFB._addedBlocks);
      } else {
        incomeFB._addedBlocks = setCriteria(pFirst, incomeFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, incomeFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        incomeFB._addedBlocks = setCriteria(pLast, incomeFB.parameters, param,
            SqlSyntax.GreaterThan, incomeFB._addedBlocks);
      } else {
        incomeFB._addedBlocks = setCriteria(pLast, incomeFB.parameters, param,
            SqlSyntax.LessThanOrEquals, incomeFB._addedBlocks);
      }
    }
    _waitingNot = '';
    incomeFB._addedBlocks.needEndBlock[incomeFB._blockIndex] =
        incomeFB._addedBlocks.retVal;
    return incomeFB;
  }

  IncomeFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    incomeFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, incomeFB.parameters, param, SqlSyntax.GreaterThan,
            incomeFB._addedBlocks)
        : setCriteria(pValue, incomeFB.parameters, param,
            SqlSyntax.LessThanOrEquals, incomeFB._addedBlocks);
    _waitingNot = '';
    incomeFB._addedBlocks.needEndBlock[incomeFB._blockIndex] =
        incomeFB._addedBlocks.retVal;
    return incomeFB;
  }

  IncomeFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    incomeFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, incomeFB.parameters, param, SqlSyntax.LessThan,
            incomeFB._addedBlocks)
        : setCriteria(pValue, incomeFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, incomeFB._addedBlocks);
    _waitingNot = '';
    incomeFB._addedBlocks.needEndBlock[incomeFB._blockIndex] =
        incomeFB._addedBlocks.retVal;
    return incomeFB;
  }

  IncomeFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    incomeFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, incomeFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, incomeFB._addedBlocks)
        : setCriteria(pValue, incomeFB.parameters, param, SqlSyntax.LessThan,
            incomeFB._addedBlocks);
    _waitingNot = '';
    incomeFB._addedBlocks.needEndBlock[incomeFB._blockIndex] =
        incomeFB._addedBlocks.retVal;
    return incomeFB;
  }

  IncomeFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    incomeFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, incomeFB.parameters, param,
            SqlSyntax.LessThanOrEquals, incomeFB._addedBlocks)
        : setCriteria(pValue, incomeFB.parameters, param, SqlSyntax.GreaterThan,
            incomeFB._addedBlocks);
    _waitingNot = '';
    incomeFB._addedBlocks.needEndBlock[incomeFB._blockIndex] =
        incomeFB._addedBlocks.retVal;
    return incomeFB;
  }

  IncomeFilterBuilder inValues(dynamic pValue) {
    incomeFB._addedBlocks = setCriteria(
        pValue,
        incomeFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        incomeFB._addedBlocks);
    _waitingNot = '';
    incomeFB._addedBlocks.needEndBlock[incomeFB._blockIndex] =
        incomeFB._addedBlocks.retVal;
    return incomeFB;
  }
}
// endregion IncomeField

// region IncomeFilterBuilder
class IncomeFilterBuilder extends SearchCriteria {
  IncomeFilterBuilder(Income obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  Income _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  IncomeFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  IncomeFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  IncomeFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  IncomeFilterBuilder where(String whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  IncomeFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  IncomeFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  IncomeFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  IncomeFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  IncomeFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  IncomeFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  IncomeFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  IncomeField setField(IncomeField field, String colName, DbType dbtype) {
    return IncomeField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  IncomeField _income_id;
  IncomeField get income_id {
    return _income_id = setField(_income_id, 'income_id', DbType.integer);
  }

  IncomeField _note;
  IncomeField get note {
    return _note = setField(_note, 'note', DbType.text);
  }

  IncomeField _income_category_id;
  IncomeField get income_category_id {
    return _income_category_id =
        setField(_income_category_id, 'income_category_id', DbType.integer);
  }

  IncomeField _price;
  IncomeField get price {
    return _price = setField(_price, 'price', DbType.integer);
  }

  IncomeField _year;
  IncomeField get year {
    return _year = setField(_year, 'year', DbType.integer);
  }

  IncomeField _month;
  IncomeField get month {
    return _month = setField(_month, 'month', DbType.integer);
  }

  IncomeField _date;
  IncomeField get date {
    return _date = setField(_date, 'date', DbType.integer);
  }

  IncomeField _created_at;
  IncomeField get created_at {
    return _created_at = setField(_created_at, 'created_at', DbType.datetime);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (Income._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<Income> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();

    if (Income._softDeleteActivated && !hardDelete) {
      r = await _obj._mnIncome.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnIncome.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'income_id IN (SELECT income_id from income ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnIncome.updateBatch(qparams, values);
  }

  /// This method always returns Income Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Income>
  Future<Income> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnIncome.toList(qparams);
    final data = await objFuture;
    Income obj;
    if (data.isNotEmpty) {
      obj = Income.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('incomecategory.plIncomeCategory') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plIncomeCategory'))) {
          /*_loadedFields.add('incomecategory.plIncomeCategory');*/
          obj.plIncomeCategory = obj.plIncomeCategory ??
              await obj.getIncomeCategory(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [Income]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) incomeCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final incomesFuture = await _obj._mnIncome.toList(qparams);
    final int count = incomesFuture[0]['CNT'] as int;
    if (incomeCount != null) {
      incomeCount(count);
    }
    return count;
  }

  /// This method returns List<Income> [Income]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Income>
  Future<List<Income>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<Income> incomesData = await Income.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return incomesData;
  }

  /// This method returns Json String [Income]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Income]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Income]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnIncome.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Income]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `income_id` FROM income WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> income_idData = <int>[];
    qparams.selectColumns = ['income_id'];
    final income_idFuture = await _obj._mnIncome.toList(qparams);

    final int count = income_idFuture.length;
    for (int i = 0; i < count; i++) {
      income_idData.add(income_idFuture[i]['income_id'] as int);
    }
    return income_idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Income]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnIncome.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await Income.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnIncome.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion IncomeFilterBuilder

// region IncomeFields
class IncomeFields {
  static TableField _fIncome_id;
  static TableField get income_id {
    return _fIncome_id = _fIncome_id ??
        SqlSyntax.setField(_fIncome_id, 'income_id', DbType.integer);
  }

  static TableField _fNote;
  static TableField get note {
    return _fNote = _fNote ?? SqlSyntax.setField(_fNote, 'note', DbType.text);
  }

  static TableField _fIncome_category_id;
  static TableField get income_category_id {
    return _fIncome_category_id = _fIncome_category_id ??
        SqlSyntax.setField(
            _fIncome_category_id, 'income_category_id', DbType.integer);
  }

  static TableField _fPrice;
  static TableField get price {
    return _fPrice =
        _fPrice ?? SqlSyntax.setField(_fPrice, 'price', DbType.integer);
  }

  static TableField _fYear;
  static TableField get year {
    return _fYear =
        _fYear ?? SqlSyntax.setField(_fYear, 'year', DbType.integer);
  }

  static TableField _fMonth;
  static TableField get month {
    return _fMonth =
        _fMonth ?? SqlSyntax.setField(_fMonth, 'month', DbType.integer);
  }

  static TableField _fDate;
  static TableField get date {
    return _fDate =
        _fDate ?? SqlSyntax.setField(_fDate, 'date', DbType.integer);
  }

  static TableField _fCreated_at;
  static TableField get created_at {
    return _fCreated_at = _fCreated_at ??
        SqlSyntax.setField(_fCreated_at, 'created_at', DbType.datetime);
  }
}
// endregion IncomeFields

//region IncomeManager
class IncomeManager extends SqfEntityProvider {
  IncomeManager()
      : super(DbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'income';
  static final List<String> _primaryKeyList = ['income_id'];
  static final String _whereStr = 'income_id=?';
}

//endregion IncomeManager
// region ExpenseCategory
class ExpenseCategory {
  ExpenseCategory(
      {this.expense_category_id,
      this.name,
      this.budget,
      this.priority,
      this.icon_id,
      this.created_at}) {
    _setDefaultValues();
  }
  ExpenseCategory.withFields(
      this.name, this.budget, this.priority, this.icon_id, this.created_at) {
    _setDefaultValues();
  }
  ExpenseCategory.withId(this.expense_category_id, this.name, this.budget,
      this.priority, this.icon_id, this.created_at) {
    _setDefaultValues();
  }
  ExpenseCategory.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    expense_category_id = int.tryParse(o['expense_category_id'].toString());
    if (o['name'] != null) {
      name = o['name'] as String;
    }
    if (o['budget'] != null) {
      budget = int.tryParse(o['budget'].toString());
    }
    if (o['priority'] != null) {
      priority = int.tryParse(o['priority'].toString());
    }
    icon_id = int.tryParse(o['icon_id'].toString());

    if (o['created_at'] != null) {
      created_at = int.tryParse(o['created_at'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['created_at'].toString()))
          : DateTime.tryParse(o['created_at'].toString());
    }

    // RELATIONSHIPS FromMAP
    plAppIcon = o['appIcon'] != null
        ? AppIcon.fromMap(o['appIcon'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (ExpenseCategory)
  int expense_category_id;
  String name;
  int budget;
  int priority;
  int icon_id;
  DateTime created_at;

  BoolResult saveResult;
  // end FIELDS (ExpenseCategory)

// RELATIONSHIPS (ExpenseCategory)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plAppIcon', 'plField2'..]) or so on..
  AppIcon plAppIcon;

  /// get AppIcon By Icon_id
  Future<AppIcon> getAppIcon(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await AppIcon()
        .getById(icon_id, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (ExpenseCategory)

// COLLECTIONS & VIRTUALS (ExpenseCategory)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plExpenses', 'plField2'..]) or so on..
  List<Expense> plExpenses;

  /// get Expense(s) filtered by expense_category_id=expense_category_id
  ExpenseFilterBuilder getExpenses(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (expense_category_id == null) {
      return null;
    }
    return Expense()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .expense_category_id
        .equals(expense_category_id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (ExpenseCategory)

  static const bool _softDeleteActivated = false;
  ExpenseCategoryManager __mnExpenseCategory;

  ExpenseCategoryManager get _mnExpenseCategory {
    return __mnExpenseCategory =
        __mnExpenseCategory ?? ExpenseCategoryManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (expense_category_id != null) {
      map['expense_category_id'] = expense_category_id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (budget != null) {
      map['budget'] = budget;
    }

    if (priority != null) {
      map['priority'] = priority;
    }

    if (icon_id != null) {
      map['icon_id'] = forView ? plAppIcon.name : icon_id;
    }

    if (created_at != null) {
      map['created_at'] = forJson
          ? created_at.toString()
          : forQuery
              ? created_at.millisecondsSinceEpoch
              : created_at;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (expense_category_id != null) {
      map['expense_category_id'] = expense_category_id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (budget != null) {
      map['budget'] = budget;
    }

    if (priority != null) {
      map['priority'] = priority;
    }

    if (icon_id != null) {
      map['icon_id'] = forView ? plAppIcon.name : icon_id;
    }

    if (created_at != null) {
      map['created_at'] = forJson
          ? created_at.toString()
          : forQuery
              ? created_at.millisecondsSinceEpoch
              : created_at;
    }

// COLLECTIONS (ExpenseCategory)
    if (!forQuery) {
      map['Expenses'] = await getExpenses().toMapList();
    }
// END COLLECTIONS (ExpenseCategory)

    return map;
  }

  /// This method returns Json String [ExpenseCategory]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [ExpenseCategory]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      name,
      budget,
      priority,
      icon_id,
      created_at != null ? created_at.millisecondsSinceEpoch : null
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      expense_category_id,
      name,
      budget,
      priority,
      icon_id,
      created_at != null ? created_at.millisecondsSinceEpoch : null
    ];
  }

  static Future<List<ExpenseCategory>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR ExpenseCategory.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<ExpenseCategory>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <ExpenseCategory>[];
    try {
      objList = list
          .map((expensecategory) =>
              ExpenseCategory.fromMap(expensecategory as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR ExpenseCategory.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<ExpenseCategory>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<ExpenseCategory> objList = <ExpenseCategory>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = ExpenseCategory.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('expensecategory.plExpenses') && */ (preloadFields ==
                null ||
            preloadFields.contains('plExpenses'))) {
          /*_loadedFields.add('expensecategory.plExpenses'); */
          obj.plExpenses = obj.plExpenses ??
              await obj.getExpenses().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('icon.plAppIcon') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plAppIcon'))) {
          /*_loadedFields.add('icon.plAppIcon');*/
          obj.plAppIcon = obj.plAppIcon ??
              await obj.getAppIcon(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns ExpenseCategory by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int expense_category_id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns ExpenseCategory if exist, otherwise returns null
  Future<ExpenseCategory> getById(int expense_category_id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (expense_category_id == null) {
      return null;
    }
    ExpenseCategory obj;
    final data = await _mnExpenseCategory.getById([expense_category_id]);
    if (data.length != 0) {
      obj = ExpenseCategory.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('expensecategory.plExpenses') && */ (preloadFields ==
                null ||
            preloadFields.contains('plExpenses'))) {
          /*_loadedFields.add('expensecategory.plExpenses'); */
          obj.plExpenses = obj.plExpenses ??
              await obj.getExpenses().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('icon.plAppIcon') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plAppIcon'))) {
          /*_loadedFields.add('icon.plAppIcon');*/
          obj.plAppIcon = obj.plAppIcon ??
              await obj.getAppIcon(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (ExpenseCategory) object. If the expense_category_id field is null, saves as a new record and returns new expense_category_id, if expense_category_id is not null then updates record

  /// <returns>Returns expense_category_id
  Future<int> save() async {
    if (expense_category_id == null || expense_category_id == 0) {
      expense_category_id = await _mnExpenseCategory.insert(this);
    } else {
      // expense_category_id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnExpenseCategory.update(this);
    }

    return expense_category_id;
  }

  /// saveAs ExpenseCategory. Returns a new Primary Key value of ExpenseCategory

  /// <returns>Returns a new Primary Key value of ExpenseCategory
  Future<int> saveAs() async {
    expense_category_id = null;

    return save();
  }

  /// saveAll method saves the sent List<ExpenseCategory> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<ExpenseCategory> expensecategories) async {
    // final results = _mnExpenseCategory.saveAll('INSERT OR REPLACE INTO expensecategory (expense_category_id,name, budget, priority, icon_id, created_at)  VALUES (?,?,?,?,?,?)',expensecategories);
    // return results; removed in sqfentity_gen 1.3.0+6
    await DbModel().batchStart();
    for (final obj in expensecategories) {
      await obj.save();
    }
    //    return DbModel().batchCommit();
    final result = await DbModel().batchCommit();
    for (int i = 0; i < expensecategories.length; i++) {
      if (expensecategories[i].expense_category_id == null) {
        expensecategories[i].expense_category_id = result[i] as int;
      }
    }

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns expense_category_id
  Future<int> upsert() async {
    try {
      if (await _mnExpenseCategory.rawInsert(
              'INSERT OR REPLACE INTO expensecategory (expense_category_id,name, budget, priority, icon_id, created_at)  VALUES (?,?,?,?,?,?)',
              [
                expense_category_id,
                name,
                budget,
                priority,
                icon_id,
                created_at != null ? created_at.millisecondsSinceEpoch : null
              ]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'ExpenseCategory expense_category_id=$expense_category_id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'ExpenseCategory expense_category_id=$expense_category_id did not update');
      }
      return expense_category_id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'ExpenseCategory Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<ExpenseCategory>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(
      List<ExpenseCategory> expensecategories) async {
    final results = await _mnExpenseCategory.rawInsertAll(
        'INSERT OR REPLACE INTO expensecategory (expense_category_id,name, budget, priority, icon_id, created_at)  VALUES (?,?,?,?,?,?)',
        expensecategories);
    return results;
  }

  /// Deletes ExpenseCategory

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print(
        'SQFENTITIY: delete ExpenseCategory invoked (expense_category_id=$expense_category_id)');
    if (await Expense()
            .select()
            .expense_category_id
            .equals(expense_category_id)
            .and
            .toCount() >
        0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Expense.expense_category_id)');
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnExpenseCategory.delete(QueryParams(
          whereString: 'expense_category_id=?',
          whereArguments: [expense_category_id]));
    } else {
      return _mnExpenseCategory.updateBatch(
          QueryParams(
              whereString: 'expense_category_id=?',
              whereArguments: [expense_category_id]),
          {'isDeleted': 1});
    }
  }

  ExpenseCategoryFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return ExpenseCategoryFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  ExpenseCategoryFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return ExpenseCategoryFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion expensecategory

// region ExpenseCategoryField
class ExpenseCategoryField extends SearchCriteria {
  ExpenseCategoryField(this.expensecategoryFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  ExpenseCategoryFilterBuilder expensecategoryFB;

  ExpenseCategoryField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  ExpenseCategoryFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    expensecategoryFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, expensecategoryFB.parameters, param,
            SqlSyntax.EQuals, expensecategoryFB._addedBlocks)
        : setCriteria(pValue, expensecategoryFB.parameters, param,
            SqlSyntax.NotEQuals, expensecategoryFB._addedBlocks);
    _waitingNot = '';
    expensecategoryFB._addedBlocks.needEndBlock[expensecategoryFB._blockIndex] =
        expensecategoryFB._addedBlocks.retVal;
    return expensecategoryFB;
  }

  ExpenseCategoryFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    expensecategoryFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, expensecategoryFB.parameters, param,
            SqlSyntax.EQualsOrNull, expensecategoryFB._addedBlocks)
        : setCriteria(pValue, expensecategoryFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, expensecategoryFB._addedBlocks);
    _waitingNot = '';
    expensecategoryFB._addedBlocks.needEndBlock[expensecategoryFB._blockIndex] =
        expensecategoryFB._addedBlocks.retVal;
    return expensecategoryFB;
  }

  ExpenseCategoryFilterBuilder isNull() {
    expensecategoryFB._addedBlocks = setCriteria(
        0,
        expensecategoryFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        expensecategoryFB._addedBlocks);
    _waitingNot = '';
    expensecategoryFB._addedBlocks.needEndBlock[expensecategoryFB._blockIndex] =
        expensecategoryFB._addedBlocks.retVal;
    return expensecategoryFB;
  }

  ExpenseCategoryFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      expensecategoryFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          expensecategoryFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          expensecategoryFB._addedBlocks);
      _waitingNot = '';
      expensecategoryFB
              ._addedBlocks.needEndBlock[expensecategoryFB._blockIndex] =
          expensecategoryFB._addedBlocks.retVal;
    }
    return expensecategoryFB;
  }

  ExpenseCategoryFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      expensecategoryFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          expensecategoryFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          expensecategoryFB._addedBlocks);
      _waitingNot = '';
      expensecategoryFB
              ._addedBlocks.needEndBlock[expensecategoryFB._blockIndex] =
          expensecategoryFB._addedBlocks.retVal;
      expensecategoryFB
              ._addedBlocks.needEndBlock[expensecategoryFB._blockIndex] =
          expensecategoryFB._addedBlocks.retVal;
    }
    return expensecategoryFB;
  }

  ExpenseCategoryFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      expensecategoryFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          expensecategoryFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          expensecategoryFB._addedBlocks);
      _waitingNot = '';
      expensecategoryFB
              ._addedBlocks.needEndBlock[expensecategoryFB._blockIndex] =
          expensecategoryFB._addedBlocks.retVal;
    }
    return expensecategoryFB;
  }

  ExpenseCategoryFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      expensecategoryFB._addedBlocks = setCriteria(
          pFirst,
          expensecategoryFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          expensecategoryFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        expensecategoryFB._addedBlocks = setCriteria(
            pFirst,
            expensecategoryFB.parameters,
            param,
            SqlSyntax.LessThan,
            expensecategoryFB._addedBlocks);
      } else {
        expensecategoryFB._addedBlocks = setCriteria(
            pFirst,
            expensecategoryFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            expensecategoryFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        expensecategoryFB._addedBlocks = setCriteria(
            pLast,
            expensecategoryFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            expensecategoryFB._addedBlocks);
      } else {
        expensecategoryFB._addedBlocks = setCriteria(
            pLast,
            expensecategoryFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            expensecategoryFB._addedBlocks);
      }
    }
    _waitingNot = '';
    expensecategoryFB._addedBlocks.needEndBlock[expensecategoryFB._blockIndex] =
        expensecategoryFB._addedBlocks.retVal;
    return expensecategoryFB;
  }

  ExpenseCategoryFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    expensecategoryFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, expensecategoryFB.parameters, param,
            SqlSyntax.GreaterThan, expensecategoryFB._addedBlocks)
        : setCriteria(pValue, expensecategoryFB.parameters, param,
            SqlSyntax.LessThanOrEquals, expensecategoryFB._addedBlocks);
    _waitingNot = '';
    expensecategoryFB._addedBlocks.needEndBlock[expensecategoryFB._blockIndex] =
        expensecategoryFB._addedBlocks.retVal;
    return expensecategoryFB;
  }

  ExpenseCategoryFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    expensecategoryFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, expensecategoryFB.parameters, param,
            SqlSyntax.LessThan, expensecategoryFB._addedBlocks)
        : setCriteria(pValue, expensecategoryFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, expensecategoryFB._addedBlocks);
    _waitingNot = '';
    expensecategoryFB._addedBlocks.needEndBlock[expensecategoryFB._blockIndex] =
        expensecategoryFB._addedBlocks.retVal;
    return expensecategoryFB;
  }

  ExpenseCategoryFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    expensecategoryFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, expensecategoryFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, expensecategoryFB._addedBlocks)
        : setCriteria(pValue, expensecategoryFB.parameters, param,
            SqlSyntax.LessThan, expensecategoryFB._addedBlocks);
    _waitingNot = '';
    expensecategoryFB._addedBlocks.needEndBlock[expensecategoryFB._blockIndex] =
        expensecategoryFB._addedBlocks.retVal;
    return expensecategoryFB;
  }

  ExpenseCategoryFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    expensecategoryFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, expensecategoryFB.parameters, param,
            SqlSyntax.LessThanOrEquals, expensecategoryFB._addedBlocks)
        : setCriteria(pValue, expensecategoryFB.parameters, param,
            SqlSyntax.GreaterThan, expensecategoryFB._addedBlocks);
    _waitingNot = '';
    expensecategoryFB._addedBlocks.needEndBlock[expensecategoryFB._blockIndex] =
        expensecategoryFB._addedBlocks.retVal;
    return expensecategoryFB;
  }

  ExpenseCategoryFilterBuilder inValues(dynamic pValue) {
    expensecategoryFB._addedBlocks = setCriteria(
        pValue,
        expensecategoryFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        expensecategoryFB._addedBlocks);
    _waitingNot = '';
    expensecategoryFB._addedBlocks.needEndBlock[expensecategoryFB._blockIndex] =
        expensecategoryFB._addedBlocks.retVal;
    return expensecategoryFB;
  }
}
// endregion ExpenseCategoryField

// region ExpenseCategoryFilterBuilder
class ExpenseCategoryFilterBuilder extends SearchCriteria {
  ExpenseCategoryFilterBuilder(ExpenseCategory obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  ExpenseCategory _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  ExpenseCategoryFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  ExpenseCategoryFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  ExpenseCategoryFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  ExpenseCategoryFilterBuilder where(String whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  ExpenseCategoryFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  ExpenseCategoryFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  ExpenseCategoryFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  ExpenseCategoryFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  ExpenseCategoryFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  ExpenseCategoryFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  ExpenseCategoryFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  ExpenseCategoryField setField(
      ExpenseCategoryField field, String colName, DbType dbtype) {
    return ExpenseCategoryField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  ExpenseCategoryField _expense_category_id;
  ExpenseCategoryField get expense_category_id {
    return _expense_category_id =
        setField(_expense_category_id, 'expense_category_id', DbType.integer);
  }

  ExpenseCategoryField _name;
  ExpenseCategoryField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  ExpenseCategoryField _budget;
  ExpenseCategoryField get budget {
    return _budget = setField(_budget, 'budget', DbType.integer);
  }

  ExpenseCategoryField _priority;
  ExpenseCategoryField get priority {
    return _priority = setField(_priority, 'priority', DbType.integer);
  }

  ExpenseCategoryField _icon_id;
  ExpenseCategoryField get icon_id {
    return _icon_id = setField(_icon_id, 'icon_id', DbType.integer);
  }

  ExpenseCategoryField _created_at;
  ExpenseCategoryField get created_at {
    return _created_at = setField(_created_at, 'created_at', DbType.datetime);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (ExpenseCategory._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<ExpenseCategory> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    // Check sub records where in (Expense) according to DeleteRule.NO_ACTION

    final idListExpenseBYexpense_category_id = toListPrimaryKeySQL(false);
    final resExpenseBYexpense_category_id = await Expense()
        .select()
        .where(
            'expense_category_id IN (${idListExpenseBYexpense_category_id['sql']})',
            parameterValue: idListExpenseBYexpense_category_id['args'])
        .toCount();
    if (resExpenseBYexpense_category_id > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Expense.expense_category_id)');
    }

    if (ExpenseCategory._softDeleteActivated && !hardDelete) {
      r = await _obj._mnExpenseCategory.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnExpenseCategory.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'expense_category_id IN (SELECT expense_category_id from expensecategory ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnExpenseCategory.updateBatch(qparams, values);
  }

  /// This method always returns ExpenseCategory Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<ExpenseCategory>
  Future<ExpenseCategory> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnExpenseCategory.toList(qparams);
    final data = await objFuture;
    ExpenseCategory obj;
    if (data.isNotEmpty) {
      obj = ExpenseCategory.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('expensecategory.plExpenses') && */ (preloadFields ==
                null ||
            preloadFields.contains('plExpenses'))) {
          /*_loadedFields.add('expensecategory.plExpenses'); */
          obj.plExpenses = obj.plExpenses ??
              await obj.getExpenses().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('icon.plAppIcon') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plAppIcon'))) {
          /*_loadedFields.add('icon.plAppIcon');*/
          obj.plAppIcon = obj.plAppIcon ??
              await obj.getAppIcon(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [ExpenseCategory]
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c) expensecategoryCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final expensecategoriesFuture =
        await _obj._mnExpenseCategory.toList(qparams);
    final int count = expensecategoriesFuture[0]['CNT'] as int;
    if (expensecategoryCount != null) {
      expensecategoryCount(count);
    }
    return count;
  }

  /// This method returns List<ExpenseCategory> [ExpenseCategory]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<ExpenseCategory>
  Future<List<ExpenseCategory>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<ExpenseCategory> expensecategoriesData =
        await ExpenseCategory.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return expensecategoriesData;
  }

  /// This method returns Json String [ExpenseCategory]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [ExpenseCategory]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [ExpenseCategory]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnExpenseCategory.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [ExpenseCategory]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `expense_category_id` FROM expensecategory WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> expense_category_idData = <int>[];
    qparams.selectColumns = ['expense_category_id'];
    final expense_category_idFuture =
        await _obj._mnExpenseCategory.toList(qparams);

    final int count = expense_category_idFuture.length;
    for (int i = 0; i < count; i++) {
      expense_category_idData
          .add(expense_category_idFuture[i]['expense_category_id'] as int);
    }
    return expense_category_idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [ExpenseCategory]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnExpenseCategory.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await ExpenseCategory.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnExpenseCategory.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ExpenseCategoryFilterBuilder

// region ExpenseCategoryFields
class ExpenseCategoryFields {
  static TableField _fExpense_category_id;
  static TableField get expense_category_id {
    return _fExpense_category_id = _fExpense_category_id ??
        SqlSyntax.setField(
            _fExpense_category_id, 'expense_category_id', DbType.integer);
  }

  static TableField _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField _fBudget;
  static TableField get budget {
    return _fBudget =
        _fBudget ?? SqlSyntax.setField(_fBudget, 'budget', DbType.integer);
  }

  static TableField _fPriority;
  static TableField get priority {
    return _fPriority = _fPriority ??
        SqlSyntax.setField(_fPriority, 'priority', DbType.integer);
  }

  static TableField _fIcon_id;
  static TableField get icon_id {
    return _fIcon_id =
        _fIcon_id ?? SqlSyntax.setField(_fIcon_id, 'icon_id', DbType.integer);
  }

  static TableField _fCreated_at;
  static TableField get created_at {
    return _fCreated_at = _fCreated_at ??
        SqlSyntax.setField(_fCreated_at, 'created_at', DbType.datetime);
  }
}
// endregion ExpenseCategoryFields

//region ExpenseCategoryManager
class ExpenseCategoryManager extends SqfEntityProvider {
  ExpenseCategoryManager()
      : super(DbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'expensecategory';
  static final List<String> _primaryKeyList = ['expense_category_id'];
  static final String _whereStr = 'expense_category_id=?';
}

//endregion ExpenseCategoryManager
// region IncomeCategory
class IncomeCategory {
  IncomeCategory(
      {this.income_category_id,
      this.name,
      this.priority,
      this.icon_id,
      this.created_at}) {
    _setDefaultValues();
  }
  IncomeCategory.withFields(
      this.name, this.priority, this.icon_id, this.created_at) {
    _setDefaultValues();
  }
  IncomeCategory.withId(this.income_category_id, this.name, this.priority,
      this.icon_id, this.created_at) {
    _setDefaultValues();
  }
  IncomeCategory.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    income_category_id = int.tryParse(o['income_category_id'].toString());
    if (o['name'] != null) {
      name = o['name'] as String;
    }
    if (o['priority'] != null) {
      priority = int.tryParse(o['priority'].toString());
    }
    icon_id = int.tryParse(o['icon_id'].toString());

    if (o['created_at'] != null) {
      created_at = int.tryParse(o['created_at'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['created_at'].toString()))
          : DateTime.tryParse(o['created_at'].toString());
    }

    // RELATIONSHIPS FromMAP
    plAppIcon = o['appIcon'] != null
        ? AppIcon.fromMap(o['appIcon'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (IncomeCategory)
  int income_category_id;
  String name;
  int priority;
  int icon_id;
  DateTime created_at;

  BoolResult saveResult;
  // end FIELDS (IncomeCategory)

// RELATIONSHIPS (IncomeCategory)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plAppIcon', 'plField2'..]) or so on..
  AppIcon plAppIcon;

  /// get AppIcon By Icon_id
  Future<AppIcon> getAppIcon(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await AppIcon()
        .getById(icon_id, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (IncomeCategory)

// COLLECTIONS & VIRTUALS (IncomeCategory)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plIncomes', 'plField2'..]) or so on..
  List<Income> plIncomes;

  /// get Income(s) filtered by income_category_id=income_category_id
  IncomeFilterBuilder getIncomes(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (income_category_id == null) {
      return null;
    }
    return Income()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .income_category_id
        .equals(income_category_id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (IncomeCategory)

  static const bool _softDeleteActivated = false;
  IncomeCategoryManager __mnIncomeCategory;

  IncomeCategoryManager get _mnIncomeCategory {
    return __mnIncomeCategory = __mnIncomeCategory ?? IncomeCategoryManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (income_category_id != null) {
      map['income_category_id'] = income_category_id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (priority != null) {
      map['priority'] = priority;
    }

    if (icon_id != null) {
      map['icon_id'] = forView ? plAppIcon.name : icon_id;
    }

    if (created_at != null) {
      map['created_at'] = forJson
          ? created_at.toString()
          : forQuery
              ? created_at.millisecondsSinceEpoch
              : created_at;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (income_category_id != null) {
      map['income_category_id'] = income_category_id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (priority != null) {
      map['priority'] = priority;
    }

    if (icon_id != null) {
      map['icon_id'] = forView ? plAppIcon.name : icon_id;
    }

    if (created_at != null) {
      map['created_at'] = forJson
          ? created_at.toString()
          : forQuery
              ? created_at.millisecondsSinceEpoch
              : created_at;
    }

// COLLECTIONS (IncomeCategory)
    if (!forQuery) {
      map['Incomes'] = await getIncomes().toMapList();
    }
// END COLLECTIONS (IncomeCategory)

    return map;
  }

  /// This method returns Json String [IncomeCategory]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [IncomeCategory]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      name,
      priority,
      icon_id,
      created_at != null ? created_at.millisecondsSinceEpoch : null
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      income_category_id,
      name,
      priority,
      icon_id,
      created_at != null ? created_at.millisecondsSinceEpoch : null
    ];
  }

  static Future<List<IncomeCategory>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR IncomeCategory.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<IncomeCategory>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <IncomeCategory>[];
    try {
      objList = list
          .map((incomecategory) =>
              IncomeCategory.fromMap(incomecategory as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR IncomeCategory.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<IncomeCategory>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<IncomeCategory> objList = <IncomeCategory>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = IncomeCategory.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('incomecategory.plIncomes') && */ (preloadFields ==
                null ||
            preloadFields.contains('plIncomes'))) {
          /*_loadedFields.add('incomecategory.plIncomes'); */
          obj.plIncomes = obj.plIncomes ??
              await obj.getIncomes().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('icon.plAppIcon') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plAppIcon'))) {
          /*_loadedFields.add('icon.plAppIcon');*/
          obj.plAppIcon = obj.plAppIcon ??
              await obj.getAppIcon(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns IncomeCategory by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int income_category_id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns IncomeCategory if exist, otherwise returns null
  Future<IncomeCategory> getById(int income_category_id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (income_category_id == null) {
      return null;
    }
    IncomeCategory obj;
    final data = await _mnIncomeCategory.getById([income_category_id]);
    if (data.length != 0) {
      obj = IncomeCategory.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('incomecategory.plIncomes') && */ (preloadFields ==
                null ||
            preloadFields.contains('plIncomes'))) {
          /*_loadedFields.add('incomecategory.plIncomes'); */
          obj.plIncomes = obj.plIncomes ??
              await obj.getIncomes().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('icon.plAppIcon') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plAppIcon'))) {
          /*_loadedFields.add('icon.plAppIcon');*/
          obj.plAppIcon = obj.plAppIcon ??
              await obj.getAppIcon(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (IncomeCategory) object. If the income_category_id field is null, saves as a new record and returns new income_category_id, if income_category_id is not null then updates record

  /// <returns>Returns income_category_id
  Future<int> save() async {
    if (income_category_id == null || income_category_id == 0) {
      income_category_id = await _mnIncomeCategory.insert(this);
    } else {
      // income_category_id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnIncomeCategory.update(this);
    }

    return income_category_id;
  }

  /// saveAs IncomeCategory. Returns a new Primary Key value of IncomeCategory

  /// <returns>Returns a new Primary Key value of IncomeCategory
  Future<int> saveAs() async {
    income_category_id = null;

    return save();
  }

  /// saveAll method saves the sent List<IncomeCategory> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<IncomeCategory> incomecategories) async {
    // final results = _mnIncomeCategory.saveAll('INSERT OR REPLACE INTO incomecategory (income_category_id,name, priority, icon_id, created_at)  VALUES (?,?,?,?,?)',incomecategories);
    // return results; removed in sqfentity_gen 1.3.0+6
    await DbModel().batchStart();
    for (final obj in incomecategories) {
      await obj.save();
    }
    //    return DbModel().batchCommit();
    final result = await DbModel().batchCommit();
    for (int i = 0; i < incomecategories.length; i++) {
      if (incomecategories[i].income_category_id == null) {
        incomecategories[i].income_category_id = result[i] as int;
      }
    }

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns income_category_id
  Future<int> upsert() async {
    try {
      if (await _mnIncomeCategory.rawInsert(
              'INSERT OR REPLACE INTO incomecategory (income_category_id,name, priority, icon_id, created_at)  VALUES (?,?,?,?,?)',
              [
                income_category_id,
                name,
                priority,
                icon_id,
                created_at != null ? created_at.millisecondsSinceEpoch : null
              ]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'IncomeCategory income_category_id=$income_category_id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'IncomeCategory income_category_id=$income_category_id did not update');
      }
      return income_category_id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'IncomeCategory Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<IncomeCategory>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(
      List<IncomeCategory> incomecategories) async {
    final results = await _mnIncomeCategory.rawInsertAll(
        'INSERT OR REPLACE INTO incomecategory (income_category_id,name, priority, icon_id, created_at)  VALUES (?,?,?,?,?)',
        incomecategories);
    return results;
  }

  /// Deletes IncomeCategory

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print(
        'SQFENTITIY: delete IncomeCategory invoked (income_category_id=$income_category_id)');
    if (await Income()
            .select()
            .income_category_id
            .equals(income_category_id)
            .and
            .toCount() >
        0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Income.income_category_id)');
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnIncomeCategory.delete(QueryParams(
          whereString: 'income_category_id=?',
          whereArguments: [income_category_id]));
    } else {
      return _mnIncomeCategory.updateBatch(
          QueryParams(
              whereString: 'income_category_id=?',
              whereArguments: [income_category_id]),
          {'isDeleted': 1});
    }
  }

  IncomeCategoryFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return IncomeCategoryFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  IncomeCategoryFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return IncomeCategoryFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion incomecategory

// region IncomeCategoryField
class IncomeCategoryField extends SearchCriteria {
  IncomeCategoryField(this.incomecategoryFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  IncomeCategoryFilterBuilder incomecategoryFB;

  IncomeCategoryField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  IncomeCategoryFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    incomecategoryFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, incomecategoryFB.parameters, param,
            SqlSyntax.EQuals, incomecategoryFB._addedBlocks)
        : setCriteria(pValue, incomecategoryFB.parameters, param,
            SqlSyntax.NotEQuals, incomecategoryFB._addedBlocks);
    _waitingNot = '';
    incomecategoryFB._addedBlocks.needEndBlock[incomecategoryFB._blockIndex] =
        incomecategoryFB._addedBlocks.retVal;
    return incomecategoryFB;
  }

  IncomeCategoryFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    incomecategoryFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, incomecategoryFB.parameters, param,
            SqlSyntax.EQualsOrNull, incomecategoryFB._addedBlocks)
        : setCriteria(pValue, incomecategoryFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, incomecategoryFB._addedBlocks);
    _waitingNot = '';
    incomecategoryFB._addedBlocks.needEndBlock[incomecategoryFB._blockIndex] =
        incomecategoryFB._addedBlocks.retVal;
    return incomecategoryFB;
  }

  IncomeCategoryFilterBuilder isNull() {
    incomecategoryFB._addedBlocks = setCriteria(
        0,
        incomecategoryFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        incomecategoryFB._addedBlocks);
    _waitingNot = '';
    incomecategoryFB._addedBlocks.needEndBlock[incomecategoryFB._blockIndex] =
        incomecategoryFB._addedBlocks.retVal;
    return incomecategoryFB;
  }

  IncomeCategoryFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      incomecategoryFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          incomecategoryFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          incomecategoryFB._addedBlocks);
      _waitingNot = '';
      incomecategoryFB._addedBlocks.needEndBlock[incomecategoryFB._blockIndex] =
          incomecategoryFB._addedBlocks.retVal;
    }
    return incomecategoryFB;
  }

  IncomeCategoryFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      incomecategoryFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          incomecategoryFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          incomecategoryFB._addedBlocks);
      _waitingNot = '';
      incomecategoryFB._addedBlocks.needEndBlock[incomecategoryFB._blockIndex] =
          incomecategoryFB._addedBlocks.retVal;
      incomecategoryFB._addedBlocks.needEndBlock[incomecategoryFB._blockIndex] =
          incomecategoryFB._addedBlocks.retVal;
    }
    return incomecategoryFB;
  }

  IncomeCategoryFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      incomecategoryFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          incomecategoryFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          incomecategoryFB._addedBlocks);
      _waitingNot = '';
      incomecategoryFB._addedBlocks.needEndBlock[incomecategoryFB._blockIndex] =
          incomecategoryFB._addedBlocks.retVal;
    }
    return incomecategoryFB;
  }

  IncomeCategoryFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      incomecategoryFB._addedBlocks = setCriteria(
          pFirst,
          incomecategoryFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          incomecategoryFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        incomecategoryFB._addedBlocks = setCriteria(
            pFirst,
            incomecategoryFB.parameters,
            param,
            SqlSyntax.LessThan,
            incomecategoryFB._addedBlocks);
      } else {
        incomecategoryFB._addedBlocks = setCriteria(
            pFirst,
            incomecategoryFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            incomecategoryFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        incomecategoryFB._addedBlocks = setCriteria(
            pLast,
            incomecategoryFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            incomecategoryFB._addedBlocks);
      } else {
        incomecategoryFB._addedBlocks = setCriteria(
            pLast,
            incomecategoryFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            incomecategoryFB._addedBlocks);
      }
    }
    _waitingNot = '';
    incomecategoryFB._addedBlocks.needEndBlock[incomecategoryFB._blockIndex] =
        incomecategoryFB._addedBlocks.retVal;
    return incomecategoryFB;
  }

  IncomeCategoryFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    incomecategoryFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, incomecategoryFB.parameters, param,
            SqlSyntax.GreaterThan, incomecategoryFB._addedBlocks)
        : setCriteria(pValue, incomecategoryFB.parameters, param,
            SqlSyntax.LessThanOrEquals, incomecategoryFB._addedBlocks);
    _waitingNot = '';
    incomecategoryFB._addedBlocks.needEndBlock[incomecategoryFB._blockIndex] =
        incomecategoryFB._addedBlocks.retVal;
    return incomecategoryFB;
  }

  IncomeCategoryFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    incomecategoryFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, incomecategoryFB.parameters, param,
            SqlSyntax.LessThan, incomecategoryFB._addedBlocks)
        : setCriteria(pValue, incomecategoryFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, incomecategoryFB._addedBlocks);
    _waitingNot = '';
    incomecategoryFB._addedBlocks.needEndBlock[incomecategoryFB._blockIndex] =
        incomecategoryFB._addedBlocks.retVal;
    return incomecategoryFB;
  }

  IncomeCategoryFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    incomecategoryFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, incomecategoryFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, incomecategoryFB._addedBlocks)
        : setCriteria(pValue, incomecategoryFB.parameters, param,
            SqlSyntax.LessThan, incomecategoryFB._addedBlocks);
    _waitingNot = '';
    incomecategoryFB._addedBlocks.needEndBlock[incomecategoryFB._blockIndex] =
        incomecategoryFB._addedBlocks.retVal;
    return incomecategoryFB;
  }

  IncomeCategoryFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    incomecategoryFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, incomecategoryFB.parameters, param,
            SqlSyntax.LessThanOrEquals, incomecategoryFB._addedBlocks)
        : setCriteria(pValue, incomecategoryFB.parameters, param,
            SqlSyntax.GreaterThan, incomecategoryFB._addedBlocks);
    _waitingNot = '';
    incomecategoryFB._addedBlocks.needEndBlock[incomecategoryFB._blockIndex] =
        incomecategoryFB._addedBlocks.retVal;
    return incomecategoryFB;
  }

  IncomeCategoryFilterBuilder inValues(dynamic pValue) {
    incomecategoryFB._addedBlocks = setCriteria(
        pValue,
        incomecategoryFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        incomecategoryFB._addedBlocks);
    _waitingNot = '';
    incomecategoryFB._addedBlocks.needEndBlock[incomecategoryFB._blockIndex] =
        incomecategoryFB._addedBlocks.retVal;
    return incomecategoryFB;
  }
}
// endregion IncomeCategoryField

// region IncomeCategoryFilterBuilder
class IncomeCategoryFilterBuilder extends SearchCriteria {
  IncomeCategoryFilterBuilder(IncomeCategory obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  IncomeCategory _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  IncomeCategoryFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  IncomeCategoryFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  IncomeCategoryFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  IncomeCategoryFilterBuilder where(String whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  IncomeCategoryFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  IncomeCategoryFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  IncomeCategoryFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  IncomeCategoryFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  IncomeCategoryFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  IncomeCategoryFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  IncomeCategoryFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  IncomeCategoryField setField(
      IncomeCategoryField field, String colName, DbType dbtype) {
    return IncomeCategoryField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  IncomeCategoryField _income_category_id;
  IncomeCategoryField get income_category_id {
    return _income_category_id =
        setField(_income_category_id, 'income_category_id', DbType.integer);
  }

  IncomeCategoryField _name;
  IncomeCategoryField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  IncomeCategoryField _priority;
  IncomeCategoryField get priority {
    return _priority = setField(_priority, 'priority', DbType.integer);
  }

  IncomeCategoryField _icon_id;
  IncomeCategoryField get icon_id {
    return _icon_id = setField(_icon_id, 'icon_id', DbType.integer);
  }

  IncomeCategoryField _created_at;
  IncomeCategoryField get created_at {
    return _created_at = setField(_created_at, 'created_at', DbType.datetime);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (IncomeCategory._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<IncomeCategory> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    // Check sub records where in (Income) according to DeleteRule.NO_ACTION

    final idListIncomeBYincome_category_id = toListPrimaryKeySQL(false);
    final resIncomeBYincome_category_id = await Income()
        .select()
        .where(
            'income_category_id IN (${idListIncomeBYincome_category_id['sql']})',
            parameterValue: idListIncomeBYincome_category_id['args'])
        .toCount();
    if (resIncomeBYincome_category_id > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Income.income_category_id)');
    }

    if (IncomeCategory._softDeleteActivated && !hardDelete) {
      r = await _obj._mnIncomeCategory.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnIncomeCategory.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'income_category_id IN (SELECT income_category_id from incomecategory ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnIncomeCategory.updateBatch(qparams, values);
  }

  /// This method always returns IncomeCategory Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<IncomeCategory>
  Future<IncomeCategory> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnIncomeCategory.toList(qparams);
    final data = await objFuture;
    IncomeCategory obj;
    if (data.isNotEmpty) {
      obj = IncomeCategory.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('incomecategory.plIncomes') && */ (preloadFields ==
                null ||
            preloadFields.contains('plIncomes'))) {
          /*_loadedFields.add('incomecategory.plIncomes'); */
          obj.plIncomes = obj.plIncomes ??
              await obj.getIncomes().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('icon.plAppIcon') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plAppIcon'))) {
          /*_loadedFields.add('icon.plAppIcon');*/
          obj.plAppIcon = obj.plAppIcon ??
              await obj.getAppIcon(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [IncomeCategory]
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c) incomecategoryCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final incomecategoriesFuture = await _obj._mnIncomeCategory.toList(qparams);
    final int count = incomecategoriesFuture[0]['CNT'] as int;
    if (incomecategoryCount != null) {
      incomecategoryCount(count);
    }
    return count;
  }

  /// This method returns List<IncomeCategory> [IncomeCategory]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<IncomeCategory>
  Future<List<IncomeCategory>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<IncomeCategory> incomecategoriesData =
        await IncomeCategory.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return incomecategoriesData;
  }

  /// This method returns Json String [IncomeCategory]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [IncomeCategory]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [IncomeCategory]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnIncomeCategory.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [IncomeCategory]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `income_category_id` FROM incomecategory WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> income_category_idData = <int>[];
    qparams.selectColumns = ['income_category_id'];
    final income_category_idFuture =
        await _obj._mnIncomeCategory.toList(qparams);

    final int count = income_category_idFuture.length;
    for (int i = 0; i < count; i++) {
      income_category_idData
          .add(income_category_idFuture[i]['income_category_id'] as int);
    }
    return income_category_idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [IncomeCategory]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnIncomeCategory.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await IncomeCategory.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnIncomeCategory.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion IncomeCategoryFilterBuilder

// region IncomeCategoryFields
class IncomeCategoryFields {
  static TableField _fIncome_category_id;
  static TableField get income_category_id {
    return _fIncome_category_id = _fIncome_category_id ??
        SqlSyntax.setField(
            _fIncome_category_id, 'income_category_id', DbType.integer);
  }

  static TableField _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField _fPriority;
  static TableField get priority {
    return _fPriority = _fPriority ??
        SqlSyntax.setField(_fPriority, 'priority', DbType.integer);
  }

  static TableField _fIcon_id;
  static TableField get icon_id {
    return _fIcon_id =
        _fIcon_id ?? SqlSyntax.setField(_fIcon_id, 'icon_id', DbType.integer);
  }

  static TableField _fCreated_at;
  static TableField get created_at {
    return _fCreated_at = _fCreated_at ??
        SqlSyntax.setField(_fCreated_at, 'created_at', DbType.datetime);
  }
}
// endregion IncomeCategoryFields

//region IncomeCategoryManager
class IncomeCategoryManager extends SqfEntityProvider {
  IncomeCategoryManager()
      : super(DbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'incomecategory';
  static final List<String> _primaryKeyList = ['income_category_id'];
  static final String _whereStr = 'income_category_id=?';
}

//endregion IncomeCategoryManager
// region FixedFee
class FixedFee {
  FixedFee(
      {this.fixed_fee_id,
      this.name,
      this.price,
      this.payment_cycle_id,
      this.note,
      this.priority,
      this.created_at}) {
    _setDefaultValues();
  }
  FixedFee.withFields(this.name, this.price, this.payment_cycle_id, this.note,
      this.priority, this.created_at) {
    _setDefaultValues();
  }
  FixedFee.withId(this.fixed_fee_id, this.name, this.price,
      this.payment_cycle_id, this.note, this.priority, this.created_at) {
    _setDefaultValues();
  }
  FixedFee.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    fixed_fee_id = int.tryParse(o['fixed_fee_id'].toString());
    if (o['name'] != null) {
      name = o['name'] as String;
    }
    if (o['price'] != null) {
      price = int.tryParse(o['price'].toString());
    }
    payment_cycle_id = int.tryParse(o['payment_cycle_id'].toString());

    if (o['note'] != null) {
      note = o['note'] as String;
    }
    if (o['priority'] != null) {
      priority = int.tryParse(o['priority'].toString());
    }
    if (o['created_at'] != null) {
      created_at = int.tryParse(o['created_at'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['created_at'].toString()))
          : DateTime.tryParse(o['created_at'].toString());
    }

    // RELATIONSHIPS FromMAP
    plPaymentCycle = o['paymentCycle'] != null
        ? PaymentCycle.fromMap(o['paymentCycle'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (FixedFee)
  int fixed_fee_id;
  String name;
  int price;
  int payment_cycle_id;
  String note;
  int priority;
  DateTime created_at;

  BoolResult saveResult;
  // end FIELDS (FixedFee)

// RELATIONSHIPS (FixedFee)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plPaymentCycle', 'plField2'..]) or so on..
  PaymentCycle plPaymentCycle;

  /// get PaymentCycle By Payment_cycle_id
  Future<PaymentCycle> getPaymentCycle(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await PaymentCycle().getById(payment_cycle_id,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (FixedFee)

  static const bool _softDeleteActivated = false;
  FixedFeeManager __mnFixedFee;

  FixedFeeManager get _mnFixedFee {
    return __mnFixedFee = __mnFixedFee ?? FixedFeeManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (fixed_fee_id != null) {
      map['fixed_fee_id'] = fixed_fee_id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (price != null) {
      map['price'] = price;
    }

    if (payment_cycle_id != null) {
      map['payment_cycle_id'] =
          forView ? plPaymentCycle.payment_cycle_id : payment_cycle_id;
    }

    if (note != null) {
      map['note'] = note;
    }

    if (priority != null) {
      map['priority'] = priority;
    }

    if (created_at != null) {
      map['created_at'] = forJson
          ? created_at.toString()
          : forQuery
              ? created_at.millisecondsSinceEpoch
              : created_at;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (fixed_fee_id != null) {
      map['fixed_fee_id'] = fixed_fee_id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (price != null) {
      map['price'] = price;
    }

    if (payment_cycle_id != null) {
      map['payment_cycle_id'] =
          forView ? plPaymentCycle.payment_cycle_id : payment_cycle_id;
    }

    if (note != null) {
      map['note'] = note;
    }

    if (priority != null) {
      map['priority'] = priority;
    }

    if (created_at != null) {
      map['created_at'] = forJson
          ? created_at.toString()
          : forQuery
              ? created_at.millisecondsSinceEpoch
              : created_at;
    }

    return map;
  }

  /// This method returns Json String [FixedFee]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [FixedFee]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      name,
      price,
      payment_cycle_id,
      note,
      priority,
      created_at != null ? created_at.millisecondsSinceEpoch : null
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      fixed_fee_id,
      name,
      price,
      payment_cycle_id,
      note,
      priority,
      created_at != null ? created_at.millisecondsSinceEpoch : null
    ];
  }

  static Future<List<FixedFee>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR FixedFee.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<FixedFee>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <FixedFee>[];
    try {
      objList = list
          .map((fixedfee) => FixedFee.fromMap(fixedfee as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print('SQFENTITY ERROR FixedFee.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<FixedFee>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<FixedFee> objList = <FixedFee>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = FixedFee.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('paymentcycle.plPaymentCycle') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plPaymentCycle'))) {
          /*_loadedFields.add('paymentcycle.plPaymentCycle');*/
          obj.plPaymentCycle = obj.plPaymentCycle ??
              await obj.getPaymentCycle(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns FixedFee by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int fixed_fee_id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns FixedFee if exist, otherwise returns null
  Future<FixedFee> getById(int fixed_fee_id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (fixed_fee_id == null) {
      return null;
    }
    FixedFee obj;
    final data = await _mnFixedFee.getById([fixed_fee_id]);
    if (data.length != 0) {
      obj = FixedFee.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('paymentcycle.plPaymentCycle') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plPaymentCycle'))) {
          /*_loadedFields.add('paymentcycle.plPaymentCycle');*/
          obj.plPaymentCycle = obj.plPaymentCycle ??
              await obj.getPaymentCycle(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (FixedFee) object. If the fixed_fee_id field is null, saves as a new record and returns new fixed_fee_id, if fixed_fee_id is not null then updates record

  /// <returns>Returns fixed_fee_id
  Future<int> save() async {
    if (fixed_fee_id == null || fixed_fee_id == 0) {
      fixed_fee_id = await _mnFixedFee.insert(this);
    } else {
      // fixed_fee_id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnFixedFee.update(this);
    }

    return fixed_fee_id;
  }

  /// saveAs FixedFee. Returns a new Primary Key value of FixedFee

  /// <returns>Returns a new Primary Key value of FixedFee
  Future<int> saveAs() async {
    fixed_fee_id = null;

    return save();
  }

  /// saveAll method saves the sent List<FixedFee> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<FixedFee> fixedfees) async {
    // final results = _mnFixedFee.saveAll('INSERT OR REPLACE INTO fixedfee (fixed_fee_id,name, price, payment_cycle_id, note, priority, created_at)  VALUES (?,?,?,?,?,?,?)',fixedfees);
    // return results; removed in sqfentity_gen 1.3.0+6
    await DbModel().batchStart();
    for (final obj in fixedfees) {
      await obj.save();
    }
    //    return DbModel().batchCommit();
    final result = await DbModel().batchCommit();
    for (int i = 0; i < fixedfees.length; i++) {
      if (fixedfees[i].fixed_fee_id == null) {
        fixedfees[i].fixed_fee_id = result[i] as int;
      }
    }

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns fixed_fee_id
  Future<int> upsert() async {
    try {
      if (await _mnFixedFee.rawInsert(
              'INSERT OR REPLACE INTO fixedfee (fixed_fee_id,name, price, payment_cycle_id, note, priority, created_at)  VALUES (?,?,?,?,?,?,?)',
              [
                fixed_fee_id,
                name,
                price,
                payment_cycle_id,
                note,
                priority,
                created_at != null ? created_at.millisecondsSinceEpoch : null
              ]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'FixedFee fixed_fee_id=$fixed_fee_id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'FixedFee fixed_fee_id=$fixed_fee_id did not update');
      }
      return fixed_fee_id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'FixedFee Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<FixedFee>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<FixedFee> fixedfees) async {
    final results = await _mnFixedFee.rawInsertAll(
        'INSERT OR REPLACE INTO fixedfee (fixed_fee_id,name, price, payment_cycle_id, note, priority, created_at)  VALUES (?,?,?,?,?,?,?)',
        fixedfees);
    return results;
  }

  /// Deletes FixedFee

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete FixedFee invoked (fixed_fee_id=$fixed_fee_id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnFixedFee.delete(QueryParams(
          whereString: 'fixed_fee_id=?', whereArguments: [fixed_fee_id]));
    } else {
      return _mnFixedFee.updateBatch(
          QueryParams(
              whereString: 'fixed_fee_id=?', whereArguments: [fixed_fee_id]),
          {'isDeleted': 1});
    }
  }

  FixedFeeFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return FixedFeeFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  FixedFeeFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return FixedFeeFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion fixedfee

// region FixedFeeField
class FixedFeeField extends SearchCriteria {
  FixedFeeField(this.fixedfeeFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  FixedFeeFilterBuilder fixedfeeFB;

  FixedFeeField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  FixedFeeFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    fixedfeeFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, fixedfeeFB.parameters, param, SqlSyntax.EQuals,
            fixedfeeFB._addedBlocks)
        : setCriteria(pValue, fixedfeeFB.parameters, param, SqlSyntax.NotEQuals,
            fixedfeeFB._addedBlocks);
    _waitingNot = '';
    fixedfeeFB._addedBlocks.needEndBlock[fixedfeeFB._blockIndex] =
        fixedfeeFB._addedBlocks.retVal;
    return fixedfeeFB;
  }

  FixedFeeFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    fixedfeeFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, fixedfeeFB.parameters, param,
            SqlSyntax.EQualsOrNull, fixedfeeFB._addedBlocks)
        : setCriteria(pValue, fixedfeeFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, fixedfeeFB._addedBlocks);
    _waitingNot = '';
    fixedfeeFB._addedBlocks.needEndBlock[fixedfeeFB._blockIndex] =
        fixedfeeFB._addedBlocks.retVal;
    return fixedfeeFB;
  }

  FixedFeeFilterBuilder isNull() {
    fixedfeeFB._addedBlocks = setCriteria(
        0,
        fixedfeeFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        fixedfeeFB._addedBlocks);
    _waitingNot = '';
    fixedfeeFB._addedBlocks.needEndBlock[fixedfeeFB._blockIndex] =
        fixedfeeFB._addedBlocks.retVal;
    return fixedfeeFB;
  }

  FixedFeeFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      fixedfeeFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          fixedfeeFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          fixedfeeFB._addedBlocks);
      _waitingNot = '';
      fixedfeeFB._addedBlocks.needEndBlock[fixedfeeFB._blockIndex] =
          fixedfeeFB._addedBlocks.retVal;
    }
    return fixedfeeFB;
  }

  FixedFeeFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      fixedfeeFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          fixedfeeFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          fixedfeeFB._addedBlocks);
      _waitingNot = '';
      fixedfeeFB._addedBlocks.needEndBlock[fixedfeeFB._blockIndex] =
          fixedfeeFB._addedBlocks.retVal;
      fixedfeeFB._addedBlocks.needEndBlock[fixedfeeFB._blockIndex] =
          fixedfeeFB._addedBlocks.retVal;
    }
    return fixedfeeFB;
  }

  FixedFeeFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      fixedfeeFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          fixedfeeFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          fixedfeeFB._addedBlocks);
      _waitingNot = '';
      fixedfeeFB._addedBlocks.needEndBlock[fixedfeeFB._blockIndex] =
          fixedfeeFB._addedBlocks.retVal;
    }
    return fixedfeeFB;
  }

  FixedFeeFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      fixedfeeFB._addedBlocks = setCriteria(
          pFirst,
          fixedfeeFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          fixedfeeFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        fixedfeeFB._addedBlocks = setCriteria(pFirst, fixedfeeFB.parameters,
            param, SqlSyntax.LessThan, fixedfeeFB._addedBlocks);
      } else {
        fixedfeeFB._addedBlocks = setCriteria(pFirst, fixedfeeFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, fixedfeeFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        fixedfeeFB._addedBlocks = setCriteria(pLast, fixedfeeFB.parameters,
            param, SqlSyntax.GreaterThan, fixedfeeFB._addedBlocks);
      } else {
        fixedfeeFB._addedBlocks = setCriteria(pLast, fixedfeeFB.parameters,
            param, SqlSyntax.LessThanOrEquals, fixedfeeFB._addedBlocks);
      }
    }
    _waitingNot = '';
    fixedfeeFB._addedBlocks.needEndBlock[fixedfeeFB._blockIndex] =
        fixedfeeFB._addedBlocks.retVal;
    return fixedfeeFB;
  }

  FixedFeeFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    fixedfeeFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, fixedfeeFB.parameters, param,
            SqlSyntax.GreaterThan, fixedfeeFB._addedBlocks)
        : setCriteria(pValue, fixedfeeFB.parameters, param,
            SqlSyntax.LessThanOrEquals, fixedfeeFB._addedBlocks);
    _waitingNot = '';
    fixedfeeFB._addedBlocks.needEndBlock[fixedfeeFB._blockIndex] =
        fixedfeeFB._addedBlocks.retVal;
    return fixedfeeFB;
  }

  FixedFeeFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    fixedfeeFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, fixedfeeFB.parameters, param, SqlSyntax.LessThan,
            fixedfeeFB._addedBlocks)
        : setCriteria(pValue, fixedfeeFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, fixedfeeFB._addedBlocks);
    _waitingNot = '';
    fixedfeeFB._addedBlocks.needEndBlock[fixedfeeFB._blockIndex] =
        fixedfeeFB._addedBlocks.retVal;
    return fixedfeeFB;
  }

  FixedFeeFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    fixedfeeFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, fixedfeeFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, fixedfeeFB._addedBlocks)
        : setCriteria(pValue, fixedfeeFB.parameters, param, SqlSyntax.LessThan,
            fixedfeeFB._addedBlocks);
    _waitingNot = '';
    fixedfeeFB._addedBlocks.needEndBlock[fixedfeeFB._blockIndex] =
        fixedfeeFB._addedBlocks.retVal;
    return fixedfeeFB;
  }

  FixedFeeFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    fixedfeeFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, fixedfeeFB.parameters, param,
            SqlSyntax.LessThanOrEquals, fixedfeeFB._addedBlocks)
        : setCriteria(pValue, fixedfeeFB.parameters, param,
            SqlSyntax.GreaterThan, fixedfeeFB._addedBlocks);
    _waitingNot = '';
    fixedfeeFB._addedBlocks.needEndBlock[fixedfeeFB._blockIndex] =
        fixedfeeFB._addedBlocks.retVal;
    return fixedfeeFB;
  }

  FixedFeeFilterBuilder inValues(dynamic pValue) {
    fixedfeeFB._addedBlocks = setCriteria(
        pValue,
        fixedfeeFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        fixedfeeFB._addedBlocks);
    _waitingNot = '';
    fixedfeeFB._addedBlocks.needEndBlock[fixedfeeFB._blockIndex] =
        fixedfeeFB._addedBlocks.retVal;
    return fixedfeeFB;
  }
}
// endregion FixedFeeField

// region FixedFeeFilterBuilder
class FixedFeeFilterBuilder extends SearchCriteria {
  FixedFeeFilterBuilder(FixedFee obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  FixedFee _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  FixedFeeFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  FixedFeeFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  FixedFeeFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  FixedFeeFilterBuilder where(String whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  FixedFeeFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  FixedFeeFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  FixedFeeFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  FixedFeeFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  FixedFeeFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  FixedFeeFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  FixedFeeFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  FixedFeeField setField(FixedFeeField field, String colName, DbType dbtype) {
    return FixedFeeField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  FixedFeeField _fixed_fee_id;
  FixedFeeField get fixed_fee_id {
    return _fixed_fee_id =
        setField(_fixed_fee_id, 'fixed_fee_id', DbType.integer);
  }

  FixedFeeField _name;
  FixedFeeField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  FixedFeeField _price;
  FixedFeeField get price {
    return _price = setField(_price, 'price', DbType.integer);
  }

  FixedFeeField _payment_cycle_id;
  FixedFeeField get payment_cycle_id {
    return _payment_cycle_id =
        setField(_payment_cycle_id, 'payment_cycle_id', DbType.integer);
  }

  FixedFeeField _note;
  FixedFeeField get note {
    return _note = setField(_note, 'note', DbType.text);
  }

  FixedFeeField _priority;
  FixedFeeField get priority {
    return _priority = setField(_priority, 'priority', DbType.integer);
  }

  FixedFeeField _created_at;
  FixedFeeField get created_at {
    return _created_at = setField(_created_at, 'created_at', DbType.datetime);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (FixedFee._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<FixedFee> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();

    if (FixedFee._softDeleteActivated && !hardDelete) {
      r = await _obj._mnFixedFee.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnFixedFee.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'fixed_fee_id IN (SELECT fixed_fee_id from fixedfee ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnFixedFee.updateBatch(qparams, values);
  }

  /// This method always returns FixedFee Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<FixedFee>
  Future<FixedFee> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnFixedFee.toList(qparams);
    final data = await objFuture;
    FixedFee obj;
    if (data.isNotEmpty) {
      obj = FixedFee.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('paymentcycle.plPaymentCycle') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plPaymentCycle'))) {
          /*_loadedFields.add('paymentcycle.plPaymentCycle');*/
          obj.plPaymentCycle = obj.plPaymentCycle ??
              await obj.getPaymentCycle(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [FixedFee]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) fixedfeeCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final fixedfeesFuture = await _obj._mnFixedFee.toList(qparams);
    final int count = fixedfeesFuture[0]['CNT'] as int;
    if (fixedfeeCount != null) {
      fixedfeeCount(count);
    }
    return count;
  }

  /// This method returns List<FixedFee> [FixedFee]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<FixedFee>
  Future<List<FixedFee>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<FixedFee> fixedfeesData = await FixedFee.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return fixedfeesData;
  }

  /// This method returns Json String [FixedFee]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [FixedFee]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [FixedFee]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnFixedFee.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [FixedFee]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `fixed_fee_id` FROM fixedfee WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> fixed_fee_idData = <int>[];
    qparams.selectColumns = ['fixed_fee_id'];
    final fixed_fee_idFuture = await _obj._mnFixedFee.toList(qparams);

    final int count = fixed_fee_idFuture.length;
    for (int i = 0; i < count; i++) {
      fixed_fee_idData.add(fixed_fee_idFuture[i]['fixed_fee_id'] as int);
    }
    return fixed_fee_idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [FixedFee]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnFixedFee.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await FixedFee.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnFixedFee.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion FixedFeeFilterBuilder

// region FixedFeeFields
class FixedFeeFields {
  static TableField _fFixed_fee_id;
  static TableField get fixed_fee_id {
    return _fFixed_fee_id = _fFixed_fee_id ??
        SqlSyntax.setField(_fFixed_fee_id, 'fixed_fee_id', DbType.integer);
  }

  static TableField _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField _fPrice;
  static TableField get price {
    return _fPrice =
        _fPrice ?? SqlSyntax.setField(_fPrice, 'price', DbType.integer);
  }

  static TableField _fPayment_cycle_id;
  static TableField get payment_cycle_id {
    return _fPayment_cycle_id = _fPayment_cycle_id ??
        SqlSyntax.setField(
            _fPayment_cycle_id, 'payment_cycle_id', DbType.integer);
  }

  static TableField _fNote;
  static TableField get note {
    return _fNote = _fNote ?? SqlSyntax.setField(_fNote, 'note', DbType.text);
  }

  static TableField _fPriority;
  static TableField get priority {
    return _fPriority = _fPriority ??
        SqlSyntax.setField(_fPriority, 'priority', DbType.integer);
  }

  static TableField _fCreated_at;
  static TableField get created_at {
    return _fCreated_at = _fCreated_at ??
        SqlSyntax.setField(_fCreated_at, 'created_at', DbType.datetime);
  }
}
// endregion FixedFeeFields

//region FixedFeeManager
class FixedFeeManager extends SqfEntityProvider {
  FixedFeeManager()
      : super(DbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'fixedfee';
  static final List<String> _primaryKeyList = ['fixed_fee_id'];
  static final String _whereStr = 'fixed_fee_id=?';
}

//endregion FixedFeeManager
// region AppIcon
class AppIcon {
  AppIcon({this.icon_id, this.name, this.priority}) {
    _setDefaultValues();
  }
  AppIcon.withFields(this.name, this.priority) {
    _setDefaultValues();
  }
  AppIcon.withId(this.icon_id, this.name, this.priority) {
    _setDefaultValues();
  }
  AppIcon.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    icon_id = int.tryParse(o['icon_id'].toString());
    if (o['name'] != null) {
      name = o['name'] as String;
    }
    if (o['priority'] != null) {
      priority = int.tryParse(o['priority'].toString());
    }
  }
  // FIELDS (AppIcon)
  int icon_id;
  String name;
  int priority;

  BoolResult saveResult;
  // end FIELDS (AppIcon)

// COLLECTIONS & VIRTUALS (AppIcon)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plExpenseCategories', 'plField2'..]) or so on..
  List<ExpenseCategory> plExpenseCategories;

  /// get ExpenseCategory(s) filtered by icon_id=icon_id
  ExpenseCategoryFilterBuilder getExpenseCategories(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (icon_id == null) {
      return null;
    }
    return ExpenseCategory()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .icon_id
        .equals(icon_id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plIncomeCategories', 'plField2'..]) or so on..
  List<IncomeCategory> plIncomeCategories;

  /// get IncomeCategory(s) filtered by icon_id=icon_id
  IncomeCategoryFilterBuilder getIncomeCategories(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (icon_id == null) {
      return null;
    }
    return IncomeCategory()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .icon_id
        .equals(icon_id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (AppIcon)

  static const bool _softDeleteActivated = false;
  AppIconManager __mnAppIcon;

  AppIconManager get _mnAppIcon {
    return __mnAppIcon = __mnAppIcon ?? AppIconManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (icon_id != null) {
      map['icon_id'] = icon_id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (priority != null) {
      map['priority'] = priority;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (icon_id != null) {
      map['icon_id'] = icon_id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (priority != null) {
      map['priority'] = priority;
    }

// COLLECTIONS (AppIcon)
    if (!forQuery) {
      map['ExpenseCategories'] = await getExpenseCategories().toMapList();
    }
    if (!forQuery) {
      map['IncomeCategories'] = await getIncomeCategories().toMapList();
    }
// END COLLECTIONS (AppIcon)

    return map;
  }

  /// This method returns Json String [AppIcon]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [AppIcon]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [name, priority];
  }

  List<dynamic> toArgsWithIds() {
    return [icon_id, name, priority];
  }

  static Future<List<AppIcon>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR AppIcon.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<AppIcon>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <AppIcon>[];
    try {
      objList = list
          .map((appicon) => AppIcon.fromMap(appicon as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print('SQFENTITY ERROR AppIcon.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<AppIcon>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<AppIcon> objList = <AppIcon>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = AppIcon.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('icon.plExpenseCategories') && */ (preloadFields ==
                null ||
            preloadFields.contains('plExpenseCategories'))) {
          /*_loadedFields.add('icon.plExpenseCategories'); */
          obj.plExpenseCategories = obj.plExpenseCategories ??
              await obj.getExpenseCategories().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('icon.plIncomeCategories') && */ (preloadFields ==
                null ||
            preloadFields.contains('plIncomeCategories'))) {
          /*_loadedFields.add('icon.plIncomeCategories'); */
          obj.plIncomeCategories = obj.plIncomeCategories ??
              await obj.getIncomeCategories().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns AppIcon by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int icon_id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns AppIcon if exist, otherwise returns null
  Future<AppIcon> getById(int icon_id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (icon_id == null) {
      return null;
    }
    AppIcon obj;
    final data = await _mnAppIcon.getById([icon_id]);
    if (data.length != 0) {
      obj = AppIcon.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('icon.plExpenseCategories') && */ (preloadFields ==
                null ||
            preloadFields.contains('plExpenseCategories'))) {
          /*_loadedFields.add('icon.plExpenseCategories'); */
          obj.plExpenseCategories = obj.plExpenseCategories ??
              await obj.getExpenseCategories().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('icon.plIncomeCategories') && */ (preloadFields ==
                null ||
            preloadFields.contains('plIncomeCategories'))) {
          /*_loadedFields.add('icon.plIncomeCategories'); */
          obj.plIncomeCategories = obj.plIncomeCategories ??
              await obj.getIncomeCategories().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (AppIcon) object. If the icon_id field is null, saves as a new record and returns new icon_id, if icon_id is not null then updates record

  /// <returns>Returns icon_id
  Future<int> save() async {
    if (icon_id == null || icon_id == 0) {
      icon_id = await _mnAppIcon.insert(this);
    } else {
      // icon_id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnAppIcon.update(this);
    }

    return icon_id;
  }

  /// saveAs AppIcon. Returns a new Primary Key value of AppIcon

  /// <returns>Returns a new Primary Key value of AppIcon
  Future<int> saveAs() async {
    icon_id = null;

    return save();
  }

  /// saveAll method saves the sent List<AppIcon> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<AppIcon> appicons) async {
    // final results = _mnAppIcon.saveAll('INSERT OR REPLACE INTO icon (icon_id,name, priority)  VALUES (?,?,?)',appicons);
    // return results; removed in sqfentity_gen 1.3.0+6
    await DbModel().batchStart();
    for (final obj in appicons) {
      await obj.save();
    }
    //    return DbModel().batchCommit();
    final result = await DbModel().batchCommit();
    for (int i = 0; i < appicons.length; i++) {
      if (appicons[i].icon_id == null) {
        appicons[i].icon_id = result[i] as int;
      }
    }

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns icon_id
  Future<int> upsert() async {
    try {
      if (await _mnAppIcon.rawInsert(
              'INSERT OR REPLACE INTO icon (icon_id,name, priority)  VALUES (?,?,?)',
              [icon_id, name, priority]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'AppIcon icon_id=$icon_id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'AppIcon icon_id=$icon_id did not update');
      }
      return icon_id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'AppIcon Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<AppIcon>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<AppIcon> appicons) async {
    final results = await _mnAppIcon.rawInsertAll(
        'INSERT OR REPLACE INTO icon (icon_id,name, priority)  VALUES (?,?,?)',
        appicons);
    return results;
  }

  /// Deletes AppIcon

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete AppIcon invoked (icon_id=$icon_id)');
    if (await ExpenseCategory().select().icon_id.equals(icon_id).and.toCount() >
        0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (ExpenseCategory.icon_id)');
    }
    if (await IncomeCategory().select().icon_id.equals(icon_id).and.toCount() >
        0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (IncomeCategory.icon_id)');
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnAppIcon.delete(
          QueryParams(whereString: 'icon_id=?', whereArguments: [icon_id]));
    } else {
      return _mnAppIcon.updateBatch(
          QueryParams(whereString: 'icon_id=?', whereArguments: [icon_id]),
          {'isDeleted': 1});
    }
  }

  AppIconFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return AppIconFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  AppIconFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return AppIconFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion appicon

// region AppIconField
class AppIconField extends SearchCriteria {
  AppIconField(this.appiconFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  AppIconFilterBuilder appiconFB;

  AppIconField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  AppIconFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    appiconFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, appiconFB.parameters, param, SqlSyntax.EQuals,
            appiconFB._addedBlocks)
        : setCriteria(pValue, appiconFB.parameters, param, SqlSyntax.NotEQuals,
            appiconFB._addedBlocks);
    _waitingNot = '';
    appiconFB._addedBlocks.needEndBlock[appiconFB._blockIndex] =
        appiconFB._addedBlocks.retVal;
    return appiconFB;
  }

  AppIconFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    appiconFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, appiconFB.parameters, param,
            SqlSyntax.EQualsOrNull, appiconFB._addedBlocks)
        : setCriteria(pValue, appiconFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, appiconFB._addedBlocks);
    _waitingNot = '';
    appiconFB._addedBlocks.needEndBlock[appiconFB._blockIndex] =
        appiconFB._addedBlocks.retVal;
    return appiconFB;
  }

  AppIconFilterBuilder isNull() {
    appiconFB._addedBlocks = setCriteria(
        0,
        appiconFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        appiconFB._addedBlocks);
    _waitingNot = '';
    appiconFB._addedBlocks.needEndBlock[appiconFB._blockIndex] =
        appiconFB._addedBlocks.retVal;
    return appiconFB;
  }

  AppIconFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      appiconFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          appiconFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          appiconFB._addedBlocks);
      _waitingNot = '';
      appiconFB._addedBlocks.needEndBlock[appiconFB._blockIndex] =
          appiconFB._addedBlocks.retVal;
    }
    return appiconFB;
  }

  AppIconFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      appiconFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          appiconFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          appiconFB._addedBlocks);
      _waitingNot = '';
      appiconFB._addedBlocks.needEndBlock[appiconFB._blockIndex] =
          appiconFB._addedBlocks.retVal;
      appiconFB._addedBlocks.needEndBlock[appiconFB._blockIndex] =
          appiconFB._addedBlocks.retVal;
    }
    return appiconFB;
  }

  AppIconFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      appiconFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          appiconFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          appiconFB._addedBlocks);
      _waitingNot = '';
      appiconFB._addedBlocks.needEndBlock[appiconFB._blockIndex] =
          appiconFB._addedBlocks.retVal;
    }
    return appiconFB;
  }

  AppIconFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      appiconFB._addedBlocks = setCriteria(
          pFirst,
          appiconFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          appiconFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        appiconFB._addedBlocks = setCriteria(pFirst, appiconFB.parameters,
            param, SqlSyntax.LessThan, appiconFB._addedBlocks);
      } else {
        appiconFB._addedBlocks = setCriteria(pFirst, appiconFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, appiconFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        appiconFB._addedBlocks = setCriteria(pLast, appiconFB.parameters, param,
            SqlSyntax.GreaterThan, appiconFB._addedBlocks);
      } else {
        appiconFB._addedBlocks = setCriteria(pLast, appiconFB.parameters, param,
            SqlSyntax.LessThanOrEquals, appiconFB._addedBlocks);
      }
    }
    _waitingNot = '';
    appiconFB._addedBlocks.needEndBlock[appiconFB._blockIndex] =
        appiconFB._addedBlocks.retVal;
    return appiconFB;
  }

  AppIconFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    appiconFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, appiconFB.parameters, param,
            SqlSyntax.GreaterThan, appiconFB._addedBlocks)
        : setCriteria(pValue, appiconFB.parameters, param,
            SqlSyntax.LessThanOrEquals, appiconFB._addedBlocks);
    _waitingNot = '';
    appiconFB._addedBlocks.needEndBlock[appiconFB._blockIndex] =
        appiconFB._addedBlocks.retVal;
    return appiconFB;
  }

  AppIconFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    appiconFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, appiconFB.parameters, param, SqlSyntax.LessThan,
            appiconFB._addedBlocks)
        : setCriteria(pValue, appiconFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, appiconFB._addedBlocks);
    _waitingNot = '';
    appiconFB._addedBlocks.needEndBlock[appiconFB._blockIndex] =
        appiconFB._addedBlocks.retVal;
    return appiconFB;
  }

  AppIconFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    appiconFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, appiconFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, appiconFB._addedBlocks)
        : setCriteria(pValue, appiconFB.parameters, param, SqlSyntax.LessThan,
            appiconFB._addedBlocks);
    _waitingNot = '';
    appiconFB._addedBlocks.needEndBlock[appiconFB._blockIndex] =
        appiconFB._addedBlocks.retVal;
    return appiconFB;
  }

  AppIconFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    appiconFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, appiconFB.parameters, param,
            SqlSyntax.LessThanOrEquals, appiconFB._addedBlocks)
        : setCriteria(pValue, appiconFB.parameters, param,
            SqlSyntax.GreaterThan, appiconFB._addedBlocks);
    _waitingNot = '';
    appiconFB._addedBlocks.needEndBlock[appiconFB._blockIndex] =
        appiconFB._addedBlocks.retVal;
    return appiconFB;
  }

  AppIconFilterBuilder inValues(dynamic pValue) {
    appiconFB._addedBlocks = setCriteria(
        pValue,
        appiconFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        appiconFB._addedBlocks);
    _waitingNot = '';
    appiconFB._addedBlocks.needEndBlock[appiconFB._blockIndex] =
        appiconFB._addedBlocks.retVal;
    return appiconFB;
  }
}
// endregion AppIconField

// region AppIconFilterBuilder
class AppIconFilterBuilder extends SearchCriteria {
  AppIconFilterBuilder(AppIcon obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  AppIcon _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  AppIconFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  AppIconFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  AppIconFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  AppIconFilterBuilder where(String whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  AppIconFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  AppIconFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  AppIconFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  AppIconFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  AppIconFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  AppIconFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  AppIconFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  AppIconField setField(AppIconField field, String colName, DbType dbtype) {
    return AppIconField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  AppIconField _icon_id;
  AppIconField get icon_id {
    return _icon_id = setField(_icon_id, 'icon_id', DbType.integer);
  }

  AppIconField _name;
  AppIconField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  AppIconField _priority;
  AppIconField get priority {
    return _priority = setField(_priority, 'priority', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (AppIcon._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<AppIcon> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    // Check sub records where in (ExpenseCategory) according to DeleteRule.NO_ACTION

    final idListExpenseCategoryBYicon_id = toListPrimaryKeySQL(false);
    final resExpenseCategoryBYicon_id = await ExpenseCategory()
        .select()
        .where('icon_id IN (${idListExpenseCategoryBYicon_id['sql']})',
            parameterValue: idListExpenseCategoryBYicon_id['args'])
        .toCount();
    if (resExpenseCategoryBYicon_id > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (ExpenseCategory.icon_id)');
    }
// Check sub records where in (IncomeCategory) according to DeleteRule.NO_ACTION

    final idListIncomeCategoryBYicon_id = toListPrimaryKeySQL(false);
    final resIncomeCategoryBYicon_id = await IncomeCategory()
        .select()
        .where('icon_id IN (${idListIncomeCategoryBYicon_id['sql']})',
            parameterValue: idListIncomeCategoryBYicon_id['args'])
        .toCount();
    if (resIncomeCategoryBYicon_id > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (IncomeCategory.icon_id)');
    }

    if (AppIcon._softDeleteActivated && !hardDelete) {
      r = await _obj._mnAppIcon.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnAppIcon.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'icon_id IN (SELECT icon_id from icon ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnAppIcon.updateBatch(qparams, values);
  }

  /// This method always returns AppIcon Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<AppIcon>
  Future<AppIcon> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnAppIcon.toList(qparams);
    final data = await objFuture;
    AppIcon obj;
    if (data.isNotEmpty) {
      obj = AppIcon.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('icon.plExpenseCategories') && */ (preloadFields ==
                null ||
            preloadFields.contains('plExpenseCategories'))) {
          /*_loadedFields.add('icon.plExpenseCategories'); */
          obj.plExpenseCategories = obj.plExpenseCategories ??
              await obj.getExpenseCategories().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('icon.plIncomeCategories') && */ (preloadFields ==
                null ||
            preloadFields.contains('plIncomeCategories'))) {
          /*_loadedFields.add('icon.plIncomeCategories'); */
          obj.plIncomeCategories = obj.plIncomeCategories ??
              await obj.getIncomeCategories().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [AppIcon]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) appiconCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final appiconsFuture = await _obj._mnAppIcon.toList(qparams);
    final int count = appiconsFuture[0]['CNT'] as int;
    if (appiconCount != null) {
      appiconCount(count);
    }
    return count;
  }

  /// This method returns List<AppIcon> [AppIcon]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<AppIcon>
  Future<List<AppIcon>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<AppIcon> appiconsData = await AppIcon.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return appiconsData;
  }

  /// This method returns Json String [AppIcon]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [AppIcon]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [AppIcon]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnAppIcon.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [AppIcon]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `icon_id` FROM icon WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> icon_idData = <int>[];
    qparams.selectColumns = ['icon_id'];
    final icon_idFuture = await _obj._mnAppIcon.toList(qparams);

    final int count = icon_idFuture.length;
    for (int i = 0; i < count; i++) {
      icon_idData.add(icon_idFuture[i]['icon_id'] as int);
    }
    return icon_idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [AppIcon]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnAppIcon.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await AppIcon.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnAppIcon.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion AppIconFilterBuilder

// region AppIconFields
class AppIconFields {
  static TableField _fIcon_id;
  static TableField get icon_id {
    return _fIcon_id =
        _fIcon_id ?? SqlSyntax.setField(_fIcon_id, 'icon_id', DbType.integer);
  }

  static TableField _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField _fPriority;
  static TableField get priority {
    return _fPriority = _fPriority ??
        SqlSyntax.setField(_fPriority, 'priority', DbType.integer);
  }
}
// endregion AppIconFields

//region AppIconManager
class AppIconManager extends SqfEntityProvider {
  AppIconManager()
      : super(DbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'icon';
  static final List<String> _primaryKeyList = ['icon_id'];
  static final String _whereStr = 'icon_id=?';
}

//endregion AppIconManager
// region PaymentCycle
class PaymentCycle {
  PaymentCycle({this.payment_cycle_id, this.month, this.priority}) {
    _setDefaultValues();
  }
  PaymentCycle.withFields(this.month, this.priority) {
    _setDefaultValues();
  }
  PaymentCycle.withId(this.payment_cycle_id, this.month, this.priority) {
    _setDefaultValues();
  }
  PaymentCycle.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    payment_cycle_id = int.tryParse(o['payment_cycle_id'].toString());
    if (o['month'] != null) {
      month = int.tryParse(o['month'].toString());
    }
    if (o['priority'] != null) {
      priority = int.tryParse(o['priority'].toString());
    }
  }
  // FIELDS (PaymentCycle)
  int payment_cycle_id;
  int month;
  int priority;

  BoolResult saveResult;
  // end FIELDS (PaymentCycle)

// COLLECTIONS & VIRTUALS (PaymentCycle)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plFixedFees', 'plField2'..]) or so on..
  List<FixedFee> plFixedFees;

  /// get FixedFee(s) filtered by payment_cycle_id=payment_cycle_id
  FixedFeeFilterBuilder getFixedFees(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (payment_cycle_id == null) {
      return null;
    }
    return FixedFee()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .payment_cycle_id
        .equals(payment_cycle_id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (PaymentCycle)

  static const bool _softDeleteActivated = false;
  PaymentCycleManager __mnPaymentCycle;

  PaymentCycleManager get _mnPaymentCycle {
    return __mnPaymentCycle = __mnPaymentCycle ?? PaymentCycleManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (payment_cycle_id != null) {
      map['payment_cycle_id'] = payment_cycle_id;
    }
    if (month != null) {
      map['month'] = month;
    }

    if (priority != null) {
      map['priority'] = priority;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (payment_cycle_id != null) {
      map['payment_cycle_id'] = payment_cycle_id;
    }
    if (month != null) {
      map['month'] = month;
    }

    if (priority != null) {
      map['priority'] = priority;
    }

// COLLECTIONS (PaymentCycle)
    if (!forQuery) {
      map['FixedFees'] = await getFixedFees().toMapList();
    }
// END COLLECTIONS (PaymentCycle)

    return map;
  }

  /// This method returns Json String [PaymentCycle]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [PaymentCycle]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [month, priority];
  }

  List<dynamic> toArgsWithIds() {
    return [payment_cycle_id, month, priority];
  }

  static Future<List<PaymentCycle>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR PaymentCycle.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<PaymentCycle>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <PaymentCycle>[];
    try {
      objList = list
          .map((paymentcycle) =>
              PaymentCycle.fromMap(paymentcycle as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR PaymentCycle.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<PaymentCycle>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<PaymentCycle> objList = <PaymentCycle>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = PaymentCycle.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('paymentcycle.plFixedFees') && */ (preloadFields ==
                null ||
            preloadFields.contains('plFixedFees'))) {
          /*_loadedFields.add('paymentcycle.plFixedFees'); */
          obj.plFixedFees = obj.plFixedFees ??
              await obj.getFixedFees().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns PaymentCycle by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int payment_cycle_id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns PaymentCycle if exist, otherwise returns null
  Future<PaymentCycle> getById(int payment_cycle_id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (payment_cycle_id == null) {
      return null;
    }
    PaymentCycle obj;
    final data = await _mnPaymentCycle.getById([payment_cycle_id]);
    if (data.length != 0) {
      obj = PaymentCycle.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('paymentcycle.plFixedFees') && */ (preloadFields ==
                null ||
            preloadFields.contains('plFixedFees'))) {
          /*_loadedFields.add('paymentcycle.plFixedFees'); */
          obj.plFixedFees = obj.plFixedFees ??
              await obj.getFixedFees().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (PaymentCycle) object. If the payment_cycle_id field is null, saves as a new record and returns new payment_cycle_id, if payment_cycle_id is not null then updates record

  /// <returns>Returns payment_cycle_id
  Future<int> save() async {
    if (payment_cycle_id == null || payment_cycle_id == 0) {
      payment_cycle_id = await _mnPaymentCycle.insert(this);
    } else {
      // payment_cycle_id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnPaymentCycle.update(this);
    }

    return payment_cycle_id;
  }

  /// saveAs PaymentCycle. Returns a new Primary Key value of PaymentCycle

  /// <returns>Returns a new Primary Key value of PaymentCycle
  Future<int> saveAs() async {
    payment_cycle_id = null;

    return save();
  }

  /// saveAll method saves the sent List<PaymentCycle> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<PaymentCycle> paymentcycles) async {
    // final results = _mnPaymentCycle.saveAll('INSERT OR REPLACE INTO paymentcycle (payment_cycle_id,month, priority)  VALUES (?,?,?)',paymentcycles);
    // return results; removed in sqfentity_gen 1.3.0+6
    await DbModel().batchStart();
    for (final obj in paymentcycles) {
      await obj.save();
    }
    //    return DbModel().batchCommit();
    final result = await DbModel().batchCommit();
    for (int i = 0; i < paymentcycles.length; i++) {
      if (paymentcycles[i].payment_cycle_id == null) {
        paymentcycles[i].payment_cycle_id = result[i] as int;
      }
    }

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns payment_cycle_id
  Future<int> upsert() async {
    try {
      if (await _mnPaymentCycle.rawInsert(
              'INSERT OR REPLACE INTO paymentcycle (payment_cycle_id,month, priority)  VALUES (?,?,?)',
              [payment_cycle_id, month, priority]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'PaymentCycle payment_cycle_id=$payment_cycle_id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'PaymentCycle payment_cycle_id=$payment_cycle_id did not update');
      }
      return payment_cycle_id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'PaymentCycle Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<PaymentCycle>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<PaymentCycle> paymentcycles) async {
    final results = await _mnPaymentCycle.rawInsertAll(
        'INSERT OR REPLACE INTO paymentcycle (payment_cycle_id,month, priority)  VALUES (?,?,?)',
        paymentcycles);
    return results;
  }

  /// Deletes PaymentCycle

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print(
        'SQFENTITIY: delete PaymentCycle invoked (payment_cycle_id=$payment_cycle_id)');
    if (await FixedFee()
            .select()
            .payment_cycle_id
            .equals(payment_cycle_id)
            .and
            .toCount() >
        0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (FixedFee.payment_cycle_id)');
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnPaymentCycle.delete(QueryParams(
          whereString: 'payment_cycle_id=?',
          whereArguments: [payment_cycle_id]));
    } else {
      return _mnPaymentCycle.updateBatch(
          QueryParams(
              whereString: 'payment_cycle_id=?',
              whereArguments: [payment_cycle_id]),
          {'isDeleted': 1});
    }
  }

  PaymentCycleFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return PaymentCycleFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  PaymentCycleFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return PaymentCycleFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion paymentcycle

// region PaymentCycleField
class PaymentCycleField extends SearchCriteria {
  PaymentCycleField(this.paymentcycleFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  PaymentCycleFilterBuilder paymentcycleFB;

  PaymentCycleField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  PaymentCycleFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    paymentcycleFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, paymentcycleFB.parameters, param,
            SqlSyntax.EQuals, paymentcycleFB._addedBlocks)
        : setCriteria(pValue, paymentcycleFB.parameters, param,
            SqlSyntax.NotEQuals, paymentcycleFB._addedBlocks);
    _waitingNot = '';
    paymentcycleFB._addedBlocks.needEndBlock[paymentcycleFB._blockIndex] =
        paymentcycleFB._addedBlocks.retVal;
    return paymentcycleFB;
  }

  PaymentCycleFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    paymentcycleFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, paymentcycleFB.parameters, param,
            SqlSyntax.EQualsOrNull, paymentcycleFB._addedBlocks)
        : setCriteria(pValue, paymentcycleFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, paymentcycleFB._addedBlocks);
    _waitingNot = '';
    paymentcycleFB._addedBlocks.needEndBlock[paymentcycleFB._blockIndex] =
        paymentcycleFB._addedBlocks.retVal;
    return paymentcycleFB;
  }

  PaymentCycleFilterBuilder isNull() {
    paymentcycleFB._addedBlocks = setCriteria(
        0,
        paymentcycleFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        paymentcycleFB._addedBlocks);
    _waitingNot = '';
    paymentcycleFB._addedBlocks.needEndBlock[paymentcycleFB._blockIndex] =
        paymentcycleFB._addedBlocks.retVal;
    return paymentcycleFB;
  }

  PaymentCycleFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      paymentcycleFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          paymentcycleFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          paymentcycleFB._addedBlocks);
      _waitingNot = '';
      paymentcycleFB._addedBlocks.needEndBlock[paymentcycleFB._blockIndex] =
          paymentcycleFB._addedBlocks.retVal;
    }
    return paymentcycleFB;
  }

  PaymentCycleFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      paymentcycleFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          paymentcycleFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          paymentcycleFB._addedBlocks);
      _waitingNot = '';
      paymentcycleFB._addedBlocks.needEndBlock[paymentcycleFB._blockIndex] =
          paymentcycleFB._addedBlocks.retVal;
      paymentcycleFB._addedBlocks.needEndBlock[paymentcycleFB._blockIndex] =
          paymentcycleFB._addedBlocks.retVal;
    }
    return paymentcycleFB;
  }

  PaymentCycleFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      paymentcycleFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          paymentcycleFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          paymentcycleFB._addedBlocks);
      _waitingNot = '';
      paymentcycleFB._addedBlocks.needEndBlock[paymentcycleFB._blockIndex] =
          paymentcycleFB._addedBlocks.retVal;
    }
    return paymentcycleFB;
  }

  PaymentCycleFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      paymentcycleFB._addedBlocks = setCriteria(
          pFirst,
          paymentcycleFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          paymentcycleFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        paymentcycleFB._addedBlocks = setCriteria(
            pFirst,
            paymentcycleFB.parameters,
            param,
            SqlSyntax.LessThan,
            paymentcycleFB._addedBlocks);
      } else {
        paymentcycleFB._addedBlocks = setCriteria(
            pFirst,
            paymentcycleFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            paymentcycleFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        paymentcycleFB._addedBlocks = setCriteria(
            pLast,
            paymentcycleFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            paymentcycleFB._addedBlocks);
      } else {
        paymentcycleFB._addedBlocks = setCriteria(
            pLast,
            paymentcycleFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            paymentcycleFB._addedBlocks);
      }
    }
    _waitingNot = '';
    paymentcycleFB._addedBlocks.needEndBlock[paymentcycleFB._blockIndex] =
        paymentcycleFB._addedBlocks.retVal;
    return paymentcycleFB;
  }

  PaymentCycleFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    paymentcycleFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, paymentcycleFB.parameters, param,
            SqlSyntax.GreaterThan, paymentcycleFB._addedBlocks)
        : setCriteria(pValue, paymentcycleFB.parameters, param,
            SqlSyntax.LessThanOrEquals, paymentcycleFB._addedBlocks);
    _waitingNot = '';
    paymentcycleFB._addedBlocks.needEndBlock[paymentcycleFB._blockIndex] =
        paymentcycleFB._addedBlocks.retVal;
    return paymentcycleFB;
  }

  PaymentCycleFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    paymentcycleFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, paymentcycleFB.parameters, param,
            SqlSyntax.LessThan, paymentcycleFB._addedBlocks)
        : setCriteria(pValue, paymentcycleFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, paymentcycleFB._addedBlocks);
    _waitingNot = '';
    paymentcycleFB._addedBlocks.needEndBlock[paymentcycleFB._blockIndex] =
        paymentcycleFB._addedBlocks.retVal;
    return paymentcycleFB;
  }

  PaymentCycleFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    paymentcycleFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, paymentcycleFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, paymentcycleFB._addedBlocks)
        : setCriteria(pValue, paymentcycleFB.parameters, param,
            SqlSyntax.LessThan, paymentcycleFB._addedBlocks);
    _waitingNot = '';
    paymentcycleFB._addedBlocks.needEndBlock[paymentcycleFB._blockIndex] =
        paymentcycleFB._addedBlocks.retVal;
    return paymentcycleFB;
  }

  PaymentCycleFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    paymentcycleFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, paymentcycleFB.parameters, param,
            SqlSyntax.LessThanOrEquals, paymentcycleFB._addedBlocks)
        : setCriteria(pValue, paymentcycleFB.parameters, param,
            SqlSyntax.GreaterThan, paymentcycleFB._addedBlocks);
    _waitingNot = '';
    paymentcycleFB._addedBlocks.needEndBlock[paymentcycleFB._blockIndex] =
        paymentcycleFB._addedBlocks.retVal;
    return paymentcycleFB;
  }

  PaymentCycleFilterBuilder inValues(dynamic pValue) {
    paymentcycleFB._addedBlocks = setCriteria(
        pValue,
        paymentcycleFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        paymentcycleFB._addedBlocks);
    _waitingNot = '';
    paymentcycleFB._addedBlocks.needEndBlock[paymentcycleFB._blockIndex] =
        paymentcycleFB._addedBlocks.retVal;
    return paymentcycleFB;
  }
}
// endregion PaymentCycleField

// region PaymentCycleFilterBuilder
class PaymentCycleFilterBuilder extends SearchCriteria {
  PaymentCycleFilterBuilder(PaymentCycle obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  PaymentCycle _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  PaymentCycleFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  PaymentCycleFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  PaymentCycleFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  PaymentCycleFilterBuilder where(String whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  PaymentCycleFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  PaymentCycleFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  PaymentCycleFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  PaymentCycleFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  PaymentCycleFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  PaymentCycleFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  PaymentCycleFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  PaymentCycleField setField(
      PaymentCycleField field, String colName, DbType dbtype) {
    return PaymentCycleField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  PaymentCycleField _payment_cycle_id;
  PaymentCycleField get payment_cycle_id {
    return _payment_cycle_id =
        setField(_payment_cycle_id, 'payment_cycle_id', DbType.integer);
  }

  PaymentCycleField _month;
  PaymentCycleField get month {
    return _month = setField(_month, 'month', DbType.integer);
  }

  PaymentCycleField _priority;
  PaymentCycleField get priority {
    return _priority = setField(_priority, 'priority', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (PaymentCycle._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<PaymentCycle> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    // Check sub records where in (FixedFee) according to DeleteRule.NO_ACTION

    final idListFixedFeeBYpayment_cycle_id = toListPrimaryKeySQL(false);
    final resFixedFeeBYpayment_cycle_id = await FixedFee()
        .select()
        .where(
            'payment_cycle_id IN (${idListFixedFeeBYpayment_cycle_id['sql']})',
            parameterValue: idListFixedFeeBYpayment_cycle_id['args'])
        .toCount();
    if (resFixedFeeBYpayment_cycle_id > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (FixedFee.payment_cycle_id)');
    }

    if (PaymentCycle._softDeleteActivated && !hardDelete) {
      r = await _obj._mnPaymentCycle.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnPaymentCycle.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'payment_cycle_id IN (SELECT payment_cycle_id from paymentcycle ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnPaymentCycle.updateBatch(qparams, values);
  }

  /// This method always returns PaymentCycle Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<PaymentCycle>
  Future<PaymentCycle> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnPaymentCycle.toList(qparams);
    final data = await objFuture;
    PaymentCycle obj;
    if (data.isNotEmpty) {
      obj = PaymentCycle.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('paymentcycle.plFixedFees') && */ (preloadFields ==
                null ||
            preloadFields.contains('plFixedFees'))) {
          /*_loadedFields.add('paymentcycle.plFixedFees'); */
          obj.plFixedFees = obj.plFixedFees ??
              await obj.getFixedFees().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [PaymentCycle]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) paymentcycleCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final paymentcyclesFuture = await _obj._mnPaymentCycle.toList(qparams);
    final int count = paymentcyclesFuture[0]['CNT'] as int;
    if (paymentcycleCount != null) {
      paymentcycleCount(count);
    }
    return count;
  }

  /// This method returns List<PaymentCycle> [PaymentCycle]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<PaymentCycle>
  Future<List<PaymentCycle>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<PaymentCycle> paymentcyclesData = await PaymentCycle.fromMapList(
        data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return paymentcyclesData;
  }

  /// This method returns Json String [PaymentCycle]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [PaymentCycle]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [PaymentCycle]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnPaymentCycle.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [PaymentCycle]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `payment_cycle_id` FROM paymentcycle WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> payment_cycle_idData = <int>[];
    qparams.selectColumns = ['payment_cycle_id'];
    final payment_cycle_idFuture = await _obj._mnPaymentCycle.toList(qparams);

    final int count = payment_cycle_idFuture.length;
    for (int i = 0; i < count; i++) {
      payment_cycle_idData
          .add(payment_cycle_idFuture[i]['payment_cycle_id'] as int);
    }
    return payment_cycle_idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [PaymentCycle]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnPaymentCycle.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await PaymentCycle.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnPaymentCycle.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion PaymentCycleFilterBuilder

// region PaymentCycleFields
class PaymentCycleFields {
  static TableField _fPayment_cycle_id;
  static TableField get payment_cycle_id {
    return _fPayment_cycle_id = _fPayment_cycle_id ??
        SqlSyntax.setField(
            _fPayment_cycle_id, 'payment_cycle_id', DbType.integer);
  }

  static TableField _fMonth;
  static TableField get month {
    return _fMonth =
        _fMonth ?? SqlSyntax.setField(_fMonth, 'month', DbType.integer);
  }

  static TableField _fPriority;
  static TableField get priority {
    return _fPriority = _fPriority ??
        SqlSyntax.setField(_fPriority, 'priority', DbType.integer);
  }
}
// endregion PaymentCycleFields

//region PaymentCycleManager
class PaymentCycleManager extends SqfEntityProvider {
  PaymentCycleManager()
      : super(DbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'paymentcycle';
  static final List<String> _primaryKeyList = ['payment_cycle_id'];
  static final String _whereStr = 'payment_cycle_id=?';
}

//endregion PaymentCycleManager
class DbModelSequenceManager extends SqfEntityProvider {
  DbModelSequenceManager() : super(DbModel());
}
// END OF ENTITIES
