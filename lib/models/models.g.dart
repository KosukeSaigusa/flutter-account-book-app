// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'models.dart';

// **************************************************************************
// SqfEntityGenerator
// **************************************************************************

//  These classes was generated by SqfEntity
//  Copyright (c) 2019, All rights reserved. Use of this source code is governed by a
//  Apache license that can be found in the LICENSE file.

//  To use these SqfEntity classes do following:
//  - import model.dart into where to use
//  - start typing ex:Expense.select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
//  - and then just put end of filters / or end of only select()  toSingle() / or toList()
//  - you can select one or return List<yourObject> by your filters and orders
//  - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
//    Enjoy.. Huseyin Tokpunar

// ignore_for_file:
// BEGIN TABLES
// Expense TABLE
class TableExpense extends SqfEntityTableBase {
  TableExpense() {
    // declare properties of EntityTable
    tableName = 'expense';
    primaryKeyName = 'expense_id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('note', DbType.text, isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableExpensecategory.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'expense_category_id',
          isNotNull: false),
      SqfEntityFieldBase('price', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('satisfaction', DbType.integer,
          defaultValue: 3, isNotNull: false, minValue: 1, maxValue: 5),
      SqfEntityFieldBase('year', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('month', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('date', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('created_at', DbType.datetime,
          isNotNull: false, minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableExpense();
  }
}

// Income TABLE
class TableIncome extends SqfEntityTableBase {
  TableIncome() {
    // declare properties of EntityTable
    tableName = 'income';
    primaryKeyName = 'income_id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('note', DbType.text, isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableIncomecategory.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'income_category_id',
          isNotNull: false),
      SqfEntityFieldBase('price', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('year', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('month', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('date', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('created_at', DbType.datetime,
          isNotNull: false, minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableIncome();
  }
}

// Expensecategory TABLE
class TableExpensecategory extends SqfEntityTableBase {
  TableExpensecategory() {
    // declare properties of EntityTable
    tableName = 'expensecategory';
    primaryKeyName = 'expense_category_id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text, isNotNull: false),
      SqfEntityFieldBase('budget', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('priority', DbType.integer, isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableIcon.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'icon_id',
          isNotNull: false),
      SqfEntityFieldBase('created_at', DbType.datetime,
          isNotNull: false, minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableExpensecategory();
  }
}

// Incomecategory TABLE
class TableIncomecategory extends SqfEntityTableBase {
  TableIncomecategory() {
    // declare properties of EntityTable
    tableName = 'incomecategory';
    primaryKeyName = 'income_category_id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text, isNotNull: false),
      SqfEntityFieldBase('priority', DbType.integer, isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableIcon.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'icon_id',
          isNotNull: false),
      SqfEntityFieldBase('created_at', DbType.datetime,
          isNotNull: false, minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableIncomecategory();
  }
}

// Fixedfee TABLE
class TableFixedfee extends SqfEntityTableBase {
  TableFixedfee() {
    // declare properties of EntityTable
    tableName = 'fixedfee';
    primaryKeyName = 'fixed_fee_id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text, isNotNull: false),
      SqfEntityFieldBase('price', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('payment_cycle_id', DbType.integer, isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TablePaymentcycle.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'payment_cycle_id',
          isNotNull: false),
      SqfEntityFieldBase('created_at', DbType.datetime,
          isNotNull: false, minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableFixedfee();
  }
}

// Icon TABLE
class TableIcon extends SqfEntityTableBase {
  TableIcon() {
    // declare properties of EntityTable
    tableName = 'icon';
    primaryKeyName = 'icon_id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text, isNotNull: false),
      SqfEntityFieldBase('priority', DbType.integer, isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableIcon();
  }
}

// Paymentcycle TABLE
class TablePaymentcycle extends SqfEntityTableBase {
  TablePaymentcycle() {
    // declare properties of EntityTable
    tableName = 'paymentcycle';
    primaryKeyName = 'payment_cycle_id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('month', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('priority', DbType.integer, isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TablePaymentcycle();
  }
}
// END TABLES

// BEGIN DATABASE MODEL
class DbModel extends SqfEntityModelProvider {
  DbModel() {
    databaseName = dbModel.databaseName;
    password = dbModel.password;
    dbVersion = dbModel.dbVersion;
    databaseTables = [
      TableExpense.getInstance,
      TableIncome.getInstance,
      TableExpensecategory.getInstance,
      TableIncomecategory.getInstance,
      TableFixedfee.getInstance,
      TableIcon.getInstance,
      TablePaymentcycle.getInstance,
    ];

    bundledDatabasePath = dbModel
        .bundledDatabasePath; //'assets/sample.db'; // This value is optional. When bundledDatabasePath is empty then EntityBase creats a new database when initializing the database
  }
  Map<String, dynamic> getControllers() {
    final controllers = <String, dynamic>{};

    return controllers;
  }
}
// END DATABASE MODEL

// BEGIN ENTITIES
// region Expense
class Expense {
  Expense(
      {this.expense_id,
      this.note,
      this.expense_category_id,
      this.price,
      this.satisfaction,
      this.year,
      this.month,
      this.date,
      this.created_at,
      this.isDeleted}) {
    _setDefaultValues();
  }
  Expense.withFields(
      this.note,
      this.expense_category_id,
      this.price,
      this.satisfaction,
      this.year,
      this.month,
      this.date,
      this.created_at,
      this.isDeleted) {
    _setDefaultValues();
  }
  Expense.withId(
      this.expense_id,
      this.note,
      this.expense_category_id,
      this.price,
      this.satisfaction,
      this.year,
      this.month,
      this.date,
      this.created_at,
      this.isDeleted) {
    _setDefaultValues();
  }
  Expense.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    expense_id = int.tryParse(o['expense_id'].toString());
    if (o['note'] != null) {
      note = o['note'] as String;
    }
    expense_category_id = int.tryParse(o['expense_category_id'].toString());

    if (o['price'] != null) {
      price = int.tryParse(o['price'].toString());
    }
    if (o['satisfaction'] != null) {
      satisfaction = int.tryParse(o['satisfaction'].toString());
    }
    if (o['year'] != null) {
      year = int.tryParse(o['year'].toString());
    }
    if (o['month'] != null) {
      month = int.tryParse(o['month'].toString());
    }
    if (o['date'] != null) {
      date = int.tryParse(o['date'].toString());
    }
    if (o['created_at'] != null) {
      created_at = int.tryParse(o['created_at'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['created_at'].toString()))
          : DateTime.tryParse(o['created_at'].toString());
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;

    // RELATIONSHIPS FromMAP
    plExpensecategory = o['expensecategory'] != null
        ? Expensecategory.fromMap(o['expensecategory'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (Expense)
  int expense_id;
  String note;
  int expense_category_id;
  int price;
  int satisfaction;
  int year;
  int month;
  int date;
  DateTime created_at;
  bool isDeleted;

  BoolResult saveResult;
  // end FIELDS (Expense)

// RELATIONSHIPS (Expense)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plExpensecategory', 'plField2'..]) or so on..
  Expensecategory plExpensecategory;

  /// get Expensecategory By Expense_category_id
  Future<Expensecategory> getExpensecategory(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await Expensecategory().getById(expense_category_id,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Expense)

  static const bool _softDeleteActivated = true;
  ExpenseManager __mnExpense;

  ExpenseManager get _mnExpense {
    return __mnExpense = __mnExpense ?? ExpenseManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (expense_id != null) {
      map['expense_id'] = expense_id;
    }
    if (note != null) {
      map['note'] = note;
    }

    if (expense_category_id != null) {
      map['expense_category_id'] =
          forView ? plExpensecategory.name : expense_category_id;
    }

    if (price != null) {
      map['price'] = price;
    }

    if (satisfaction != null) {
      map['satisfaction'] = satisfaction;
    }

    if (year != null) {
      map['year'] = year;
    }

    if (month != null) {
      map['month'] = month;
    }

    if (date != null) {
      map['date'] = date;
    }

    if (created_at != null) {
      map['created_at'] = forJson
          ? created_at.toString()
          : forQuery
              ? created_at.millisecondsSinceEpoch
              : created_at;
    }

    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted ? 1 : 0) : isDeleted;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (expense_id != null) {
      map['expense_id'] = expense_id;
    }
    if (note != null) {
      map['note'] = note;
    }

    if (expense_category_id != null) {
      map['expense_category_id'] =
          forView ? plExpensecategory.name : expense_category_id;
    }

    if (price != null) {
      map['price'] = price;
    }

    if (satisfaction != null) {
      map['satisfaction'] = satisfaction;
    }

    if (year != null) {
      map['year'] = year;
    }

    if (month != null) {
      map['month'] = month;
    }

    if (date != null) {
      map['date'] = date;
    }

    if (created_at != null) {
      map['created_at'] = forJson
          ? created_at.toString()
          : forQuery
              ? created_at.millisecondsSinceEpoch
              : created_at;
    }

    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted ? 1 : 0) : isDeleted;
    }

    return map;
  }

  /// This method returns Json String [Expense]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Expense]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      note,
      expense_category_id,
      price,
      satisfaction,
      year,
      month,
      date,
      created_at != null ? created_at.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      expense_id,
      note,
      expense_category_id,
      price,
      satisfaction,
      year,
      month,
      date,
      created_at != null ? created_at.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  static Future<List<Expense>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR Expense.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<Expense>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Expense>[];
    try {
      objList = list
          .map((expense) => Expense.fromMap(expense as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print('SQFENTITY ERROR Expense.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Expense>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<Expense> objList = <Expense>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Expense.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('expensecategory.plExpensecategory') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plExpensecategory'))) {
          /*_loadedFields.add('expensecategory.plExpensecategory');*/
          obj.plExpensecategory = obj.plExpensecategory ??
              await obj.getExpensecategory(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Expense by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int expense_id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns Expense if exist, otherwise returns null
  Future<Expense> getById(int expense_id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (expense_id == null) {
      return null;
    }
    Expense obj;
    final data = await _mnExpense.getById([expense_id]);
    if (data.length != 0) {
      obj = Expense.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('expensecategory.plExpensecategory') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plExpensecategory'))) {
          /*_loadedFields.add('expensecategory.plExpensecategory');*/
          obj.plExpensecategory = obj.plExpensecategory ??
              await obj.getExpensecategory(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Expense) object. If the expense_id field is null, saves as a new record and returns new expense_id, if expense_id is not null then updates record

  /// <returns>Returns expense_id
  Future<int> save() async {
    if (expense_id == null || expense_id == 0) {
      expense_id = await _mnExpense.insert(this);
    } else {
      // expense_id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnExpense.update(this);
    }

    return expense_id;
  }

  /// saveAs Expense. Returns a new Primary Key value of Expense

  /// <returns>Returns a new Primary Key value of Expense
  Future<int> saveAs() async {
    expense_id = null;

    return save();
  }

  /// saveAll method saves the sent List<Expense> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Expense> expenses) async {
    // final results = _mnExpense.saveAll('INSERT OR REPLACE INTO expense (expense_id,note, expense_category_id, price, satisfaction, year, month, date, created_at,isDeleted)  VALUES (?,?,?,?,?,?,?,?,?,?)',expenses);
    // return results; removed in sqfentity_gen 1.3.0+6
    await DbModel().batchStart();
    for (final obj in expenses) {
      await obj.save();
    }
    //    return DbModel().batchCommit();
    final result = await DbModel().batchCommit();
    for (int i = 0; i < expenses.length; i++) {
      if (expenses[i].expense_id == null) {
        expenses[i].expense_id = result[i] as int;
      }
    }

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns expense_id
  Future<int> upsert() async {
    try {
      if (await _mnExpense.rawInsert(
              'INSERT OR REPLACE INTO expense (expense_id,note, expense_category_id, price, satisfaction, year, month, date, created_at,isDeleted)  VALUES (?,?,?,?,?,?,?,?,?,?)',
              [
                expense_id,
                note,
                expense_category_id,
                price,
                satisfaction,
                year,
                month,
                date,
                created_at != null ? created_at.millisecondsSinceEpoch : null,
                isDeleted
              ]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Expense expense_id=$expense_id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Expense expense_id=$expense_id did not update');
      }
      return expense_id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Expense Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<Expense>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<Expense> expenses) async {
    final results = await _mnExpense.rawInsertAll(
        'INSERT OR REPLACE INTO expense (expense_id,note, expense_category_id, price, satisfaction, year, month, date, created_at,isDeleted)  VALUES (?,?,?,?,?,?,?,?,?,?)',
        expenses);
    return results;
  }

  /// Deletes Expense

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete Expense invoked (expense_id=$expense_id)');
    if (!_softDeleteActivated || hardDelete || isDeleted) {
      return _mnExpense.delete(QueryParams(
          whereString: 'expense_id=?', whereArguments: [expense_id]));
    } else {
      return _mnExpense.updateBatch(
          QueryParams(
              whereString: 'expense_id=?', whereArguments: [expense_id]),
          {'isDeleted': 1});
    }
  }

  /// Recover Expense>

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    print('SQFENTITIY: recover Expense invoked (expense_id=$expense_id)');
    {
      return _mnExpense.updateBatch(
          QueryParams(
              whereString: 'expense_id=?', whereArguments: [expense_id]),
          {'isDeleted': 0});
    }
  }

  ExpenseFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return ExpenseFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  ExpenseFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return ExpenseFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    satisfaction = satisfaction ?? 3;
    isDeleted = isDeleted ?? false;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion expense

// region ExpenseField
class ExpenseField extends SearchCriteria {
  ExpenseField(this.expenseFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  ExpenseFilterBuilder expenseFB;

  ExpenseField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  ExpenseFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    expenseFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, expenseFB.parameters, param, SqlSyntax.EQuals,
            expenseFB._addedBlocks)
        : setCriteria(pValue, expenseFB.parameters, param, SqlSyntax.NotEQuals,
            expenseFB._addedBlocks);
    _waitingNot = '';
    expenseFB._addedBlocks.needEndBlock[expenseFB._blockIndex] =
        expenseFB._addedBlocks.retVal;
    return expenseFB;
  }

  ExpenseFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    expenseFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, expenseFB.parameters, param,
            SqlSyntax.EQualsOrNull, expenseFB._addedBlocks)
        : setCriteria(pValue, expenseFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, expenseFB._addedBlocks);
    _waitingNot = '';
    expenseFB._addedBlocks.needEndBlock[expenseFB._blockIndex] =
        expenseFB._addedBlocks.retVal;
    return expenseFB;
  }

  ExpenseFilterBuilder isNull() {
    expenseFB._addedBlocks = setCriteria(
        0,
        expenseFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        expenseFB._addedBlocks);
    _waitingNot = '';
    expenseFB._addedBlocks.needEndBlock[expenseFB._blockIndex] =
        expenseFB._addedBlocks.retVal;
    return expenseFB;
  }

  ExpenseFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      expenseFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          expenseFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          expenseFB._addedBlocks);
      _waitingNot = '';
      expenseFB._addedBlocks.needEndBlock[expenseFB._blockIndex] =
          expenseFB._addedBlocks.retVal;
    }
    return expenseFB;
  }

  ExpenseFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      expenseFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          expenseFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          expenseFB._addedBlocks);
      _waitingNot = '';
      expenseFB._addedBlocks.needEndBlock[expenseFB._blockIndex] =
          expenseFB._addedBlocks.retVal;
      expenseFB._addedBlocks.needEndBlock[expenseFB._blockIndex] =
          expenseFB._addedBlocks.retVal;
    }
    return expenseFB;
  }

  ExpenseFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      expenseFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          expenseFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          expenseFB._addedBlocks);
      _waitingNot = '';
      expenseFB._addedBlocks.needEndBlock[expenseFB._blockIndex] =
          expenseFB._addedBlocks.retVal;
    }
    return expenseFB;
  }

  ExpenseFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      expenseFB._addedBlocks = setCriteria(
          pFirst,
          expenseFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          expenseFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        expenseFB._addedBlocks = setCriteria(pFirst, expenseFB.parameters,
            param, SqlSyntax.LessThan, expenseFB._addedBlocks);
      } else {
        expenseFB._addedBlocks = setCriteria(pFirst, expenseFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, expenseFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        expenseFB._addedBlocks = setCriteria(pLast, expenseFB.parameters, param,
            SqlSyntax.GreaterThan, expenseFB._addedBlocks);
      } else {
        expenseFB._addedBlocks = setCriteria(pLast, expenseFB.parameters, param,
            SqlSyntax.LessThanOrEquals, expenseFB._addedBlocks);
      }
    }
    _waitingNot = '';
    expenseFB._addedBlocks.needEndBlock[expenseFB._blockIndex] =
        expenseFB._addedBlocks.retVal;
    return expenseFB;
  }

  ExpenseFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    expenseFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, expenseFB.parameters, param,
            SqlSyntax.GreaterThan, expenseFB._addedBlocks)
        : setCriteria(pValue, expenseFB.parameters, param,
            SqlSyntax.LessThanOrEquals, expenseFB._addedBlocks);
    _waitingNot = '';
    expenseFB._addedBlocks.needEndBlock[expenseFB._blockIndex] =
        expenseFB._addedBlocks.retVal;
    return expenseFB;
  }

  ExpenseFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    expenseFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, expenseFB.parameters, param, SqlSyntax.LessThan,
            expenseFB._addedBlocks)
        : setCriteria(pValue, expenseFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, expenseFB._addedBlocks);
    _waitingNot = '';
    expenseFB._addedBlocks.needEndBlock[expenseFB._blockIndex] =
        expenseFB._addedBlocks.retVal;
    return expenseFB;
  }

  ExpenseFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    expenseFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, expenseFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, expenseFB._addedBlocks)
        : setCriteria(pValue, expenseFB.parameters, param, SqlSyntax.LessThan,
            expenseFB._addedBlocks);
    _waitingNot = '';
    expenseFB._addedBlocks.needEndBlock[expenseFB._blockIndex] =
        expenseFB._addedBlocks.retVal;
    return expenseFB;
  }

  ExpenseFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    expenseFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, expenseFB.parameters, param,
            SqlSyntax.LessThanOrEquals, expenseFB._addedBlocks)
        : setCriteria(pValue, expenseFB.parameters, param,
            SqlSyntax.GreaterThan, expenseFB._addedBlocks);
    _waitingNot = '';
    expenseFB._addedBlocks.needEndBlock[expenseFB._blockIndex] =
        expenseFB._addedBlocks.retVal;
    return expenseFB;
  }

  ExpenseFilterBuilder inValues(dynamic pValue) {
    expenseFB._addedBlocks = setCriteria(
        pValue,
        expenseFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        expenseFB._addedBlocks);
    _waitingNot = '';
    expenseFB._addedBlocks.needEndBlock[expenseFB._blockIndex] =
        expenseFB._addedBlocks.retVal;
    return expenseFB;
  }
}
// endregion ExpenseField

// region ExpenseFilterBuilder
class ExpenseFilterBuilder extends SearchCriteria {
  ExpenseFilterBuilder(Expense obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  Expense _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  ExpenseFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  ExpenseFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  ExpenseFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  ExpenseFilterBuilder where(String whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  ExpenseFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  ExpenseFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  ExpenseFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  ExpenseFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  ExpenseFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  ExpenseFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  ExpenseFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  ExpenseField setField(ExpenseField field, String colName, DbType dbtype) {
    return ExpenseField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  ExpenseField _expense_id;
  ExpenseField get expense_id {
    return _expense_id = setField(_expense_id, 'expense_id', DbType.integer);
  }

  ExpenseField _note;
  ExpenseField get note {
    return _note = setField(_note, 'note', DbType.text);
  }

  ExpenseField _expense_category_id;
  ExpenseField get expense_category_id {
    return _expense_category_id =
        setField(_expense_category_id, 'expense_category_id', DbType.integer);
  }

  ExpenseField _price;
  ExpenseField get price {
    return _price = setField(_price, 'price', DbType.integer);
  }

  ExpenseField _satisfaction;
  ExpenseField get satisfaction {
    return _satisfaction =
        setField(_satisfaction, 'satisfaction', DbType.integer);
  }

  ExpenseField _year;
  ExpenseField get year {
    return _year = setField(_year, 'year', DbType.integer);
  }

  ExpenseField _month;
  ExpenseField get month {
    return _month = setField(_month, 'month', DbType.integer);
  }

  ExpenseField _date;
  ExpenseField get date {
    return _date = setField(_date, 'date', DbType.integer);
  }

  ExpenseField _created_at;
  ExpenseField get created_at {
    return _created_at = setField(_created_at, 'created_at', DbType.datetime);
  }

  ExpenseField _isDeleted;
  ExpenseField get isDeleted {
    return _isDeleted = setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (Expense._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<Expense> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();

    if (Expense._softDeleteActivated && !hardDelete) {
      r = await _obj._mnExpense.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnExpense.delete(qparams);
    }
    return r;
  }

  /// Recover List<Expense> bulk by query
  Future<BoolResult> recover() async {
    _getIsDeleted = true;
    _buildParameters();
    print('SQFENTITIY: recover Expense bulk invoked');
    return _obj._mnExpense.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'expense_id IN (SELECT expense_id from expense ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnExpense.updateBatch(qparams, values);
  }

  /// This method always returns Expense Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Expense>
  Future<Expense> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnExpense.toList(qparams);
    final data = await objFuture;
    Expense obj;
    if (data.isNotEmpty) {
      obj = Expense.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('expensecategory.plExpensecategory') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plExpensecategory'))) {
          /*_loadedFields.add('expensecategory.plExpensecategory');*/
          obj.plExpensecategory = obj.plExpensecategory ??
              await obj.getExpensecategory(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [Expense]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) expenseCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final expensesFuture = await _obj._mnExpense.toList(qparams);
    final int count = expensesFuture[0]['CNT'] as int;
    if (expenseCount != null) {
      expenseCount(count);
    }
    return count;
  }

  /// This method returns List<Expense> [Expense]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Expense>
  Future<List<Expense>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<Expense> expensesData = await Expense.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return expensesData;
  }

  /// This method returns Json String [Expense]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Expense]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Expense]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnExpense.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Expense]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `expense_id` FROM expense WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> expense_idData = <int>[];
    qparams.selectColumns = ['expense_id'];
    final expense_idFuture = await _obj._mnExpense.toList(qparams);

    final int count = expense_idFuture.length;
    for (int i = 0; i < count; i++) {
      expense_idData.add(expense_idFuture[i]['expense_id'] as int);
    }
    return expense_idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Expense]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnExpense.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await Expense.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnExpense.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ExpenseFilterBuilder

// region ExpenseFields
class ExpenseFields {
  static TableField _fExpense_id;
  static TableField get expense_id {
    return _fExpense_id = _fExpense_id ??
        SqlSyntax.setField(_fExpense_id, 'expense_id', DbType.integer);
  }

  static TableField _fNote;
  static TableField get note {
    return _fNote = _fNote ?? SqlSyntax.setField(_fNote, 'note', DbType.text);
  }

  static TableField _fExpense_category_id;
  static TableField get expense_category_id {
    return _fExpense_category_id = _fExpense_category_id ??
        SqlSyntax.setField(
            _fExpense_category_id, 'expense_category_id', DbType.integer);
  }

  static TableField _fPrice;
  static TableField get price {
    return _fPrice =
        _fPrice ?? SqlSyntax.setField(_fPrice, 'price', DbType.integer);
  }

  static TableField _fSatisfaction;
  static TableField get satisfaction {
    return _fSatisfaction = _fSatisfaction ??
        SqlSyntax.setField(_fSatisfaction, 'satisfaction', DbType.integer);
  }

  static TableField _fYear;
  static TableField get year {
    return _fYear =
        _fYear ?? SqlSyntax.setField(_fYear, 'year', DbType.integer);
  }

  static TableField _fMonth;
  static TableField get month {
    return _fMonth =
        _fMonth ?? SqlSyntax.setField(_fMonth, 'month', DbType.integer);
  }

  static TableField _fDate;
  static TableField get date {
    return _fDate =
        _fDate ?? SqlSyntax.setField(_fDate, 'date', DbType.integer);
  }

  static TableField _fCreated_at;
  static TableField get created_at {
    return _fCreated_at = _fCreated_at ??
        SqlSyntax.setField(_fCreated_at, 'created_at', DbType.datetime);
  }

  static TableField _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion ExpenseFields

//region ExpenseManager
class ExpenseManager extends SqfEntityProvider {
  ExpenseManager()
      : super(DbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'expense';
  static final List<String> _primaryKeyList = ['expense_id'];
  static final String _whereStr = 'expense_id=?';
}

//endregion ExpenseManager
// region Income
class Income {
  Income(
      {this.income_id,
      this.note,
      this.income_category_id,
      this.price,
      this.year,
      this.month,
      this.date,
      this.created_at,
      this.isDeleted}) {
    _setDefaultValues();
  }
  Income.withFields(this.note, this.income_category_id, this.price, this.year,
      this.month, this.date, this.created_at, this.isDeleted) {
    _setDefaultValues();
  }
  Income.withId(this.income_id, this.note, this.income_category_id, this.price,
      this.year, this.month, this.date, this.created_at, this.isDeleted) {
    _setDefaultValues();
  }
  Income.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    income_id = int.tryParse(o['income_id'].toString());
    if (o['note'] != null) {
      note = o['note'] as String;
    }
    income_category_id = int.tryParse(o['income_category_id'].toString());

    if (o['price'] != null) {
      price = int.tryParse(o['price'].toString());
    }
    if (o['year'] != null) {
      year = int.tryParse(o['year'].toString());
    }
    if (o['month'] != null) {
      month = int.tryParse(o['month'].toString());
    }
    if (o['date'] != null) {
      date = int.tryParse(o['date'].toString());
    }
    if (o['created_at'] != null) {
      created_at = int.tryParse(o['created_at'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['created_at'].toString()))
          : DateTime.tryParse(o['created_at'].toString());
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;

    // RELATIONSHIPS FromMAP
    plIncomecategory = o['incomecategory'] != null
        ? Incomecategory.fromMap(o['incomecategory'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (Income)
  int income_id;
  String note;
  int income_category_id;
  int price;
  int year;
  int month;
  int date;
  DateTime created_at;
  bool isDeleted;

  BoolResult saveResult;
  // end FIELDS (Income)

// RELATIONSHIPS (Income)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plIncomecategory', 'plField2'..]) or so on..
  Incomecategory plIncomecategory;

  /// get Incomecategory By Income_category_id
  Future<Incomecategory> getIncomecategory(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await Incomecategory().getById(income_category_id,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Income)

  static const bool _softDeleteActivated = true;
  IncomeManager __mnIncome;

  IncomeManager get _mnIncome {
    return __mnIncome = __mnIncome ?? IncomeManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (income_id != null) {
      map['income_id'] = income_id;
    }
    if (note != null) {
      map['note'] = note;
    }

    if (income_category_id != null) {
      map['income_category_id'] =
          forView ? plIncomecategory.name : income_category_id;
    }

    if (price != null) {
      map['price'] = price;
    }

    if (year != null) {
      map['year'] = year;
    }

    if (month != null) {
      map['month'] = month;
    }

    if (date != null) {
      map['date'] = date;
    }

    if (created_at != null) {
      map['created_at'] = forJson
          ? created_at.toString()
          : forQuery
              ? created_at.millisecondsSinceEpoch
              : created_at;
    }

    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted ? 1 : 0) : isDeleted;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (income_id != null) {
      map['income_id'] = income_id;
    }
    if (note != null) {
      map['note'] = note;
    }

    if (income_category_id != null) {
      map['income_category_id'] =
          forView ? plIncomecategory.name : income_category_id;
    }

    if (price != null) {
      map['price'] = price;
    }

    if (year != null) {
      map['year'] = year;
    }

    if (month != null) {
      map['month'] = month;
    }

    if (date != null) {
      map['date'] = date;
    }

    if (created_at != null) {
      map['created_at'] = forJson
          ? created_at.toString()
          : forQuery
              ? created_at.millisecondsSinceEpoch
              : created_at;
    }

    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted ? 1 : 0) : isDeleted;
    }

    return map;
  }

  /// This method returns Json String [Income]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Income]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      note,
      income_category_id,
      price,
      year,
      month,
      date,
      created_at != null ? created_at.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      income_id,
      note,
      income_category_id,
      price,
      year,
      month,
      date,
      created_at != null ? created_at.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  static Future<List<Income>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print('SQFENTITY ERROR Income.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<Income>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Income>[];
    try {
      objList = list
          .map((income) => Income.fromMap(income as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print('SQFENTITY ERROR Income.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Income>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<Income> objList = <Income>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Income.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('incomecategory.plIncomecategory') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plIncomecategory'))) {
          /*_loadedFields.add('incomecategory.plIncomecategory');*/
          obj.plIncomecategory = obj.plIncomecategory ??
              await obj.getIncomecategory(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Income by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int income_id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns Income if exist, otherwise returns null
  Future<Income> getById(int income_id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (income_id == null) {
      return null;
    }
    Income obj;
    final data = await _mnIncome.getById([income_id]);
    if (data.length != 0) {
      obj = Income.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('incomecategory.plIncomecategory') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plIncomecategory'))) {
          /*_loadedFields.add('incomecategory.plIncomecategory');*/
          obj.plIncomecategory = obj.plIncomecategory ??
              await obj.getIncomecategory(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Income) object. If the income_id field is null, saves as a new record and returns new income_id, if income_id is not null then updates record

  /// <returns>Returns income_id
  Future<int> save() async {
    if (income_id == null || income_id == 0) {
      income_id = await _mnIncome.insert(this);
    } else {
      // income_id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnIncome.update(this);
    }

    return income_id;
  }

  /// saveAs Income. Returns a new Primary Key value of Income

  /// <returns>Returns a new Primary Key value of Income
  Future<int> saveAs() async {
    income_id = null;

    return save();
  }

  /// saveAll method saves the sent List<Income> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Income> incomes) async {
    // final results = _mnIncome.saveAll('INSERT OR REPLACE INTO income (income_id,note, income_category_id, price, year, month, date, created_at,isDeleted)  VALUES (?,?,?,?,?,?,?,?,?)',incomes);
    // return results; removed in sqfentity_gen 1.3.0+6
    await DbModel().batchStart();
    for (final obj in incomes) {
      await obj.save();
    }
    //    return DbModel().batchCommit();
    final result = await DbModel().batchCommit();
    for (int i = 0; i < incomes.length; i++) {
      if (incomes[i].income_id == null) {
        incomes[i].income_id = result[i] as int;
      }
    }

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns income_id
  Future<int> upsert() async {
    try {
      if (await _mnIncome.rawInsert(
              'INSERT OR REPLACE INTO income (income_id,note, income_category_id, price, year, month, date, created_at,isDeleted)  VALUES (?,?,?,?,?,?,?,?,?)',
              [
                income_id,
                note,
                income_category_id,
                price,
                year,
                month,
                date,
                created_at != null ? created_at.millisecondsSinceEpoch : null,
                isDeleted
              ]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Income income_id=$income_id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Income income_id=$income_id did not update');
      }
      return income_id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Income Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<Income>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<Income> incomes) async {
    final results = await _mnIncome.rawInsertAll(
        'INSERT OR REPLACE INTO income (income_id,note, income_category_id, price, year, month, date, created_at,isDeleted)  VALUES (?,?,?,?,?,?,?,?,?)',
        incomes);
    return results;
  }

  /// Deletes Income

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete Income invoked (income_id=$income_id)');
    if (!_softDeleteActivated || hardDelete || isDeleted) {
      return _mnIncome.delete(
          QueryParams(whereString: 'income_id=?', whereArguments: [income_id]));
    } else {
      return _mnIncome.updateBatch(
          QueryParams(whereString: 'income_id=?', whereArguments: [income_id]),
          {'isDeleted': 1});
    }
  }

  /// Recover Income>

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    print('SQFENTITIY: recover Income invoked (income_id=$income_id)');
    {
      return _mnIncome.updateBatch(
          QueryParams(whereString: 'income_id=?', whereArguments: [income_id]),
          {'isDeleted': 0});
    }
  }

  IncomeFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return IncomeFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  IncomeFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return IncomeFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isDeleted = isDeleted ?? false;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion income

// region IncomeField
class IncomeField extends SearchCriteria {
  IncomeField(this.incomeFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  IncomeFilterBuilder incomeFB;

  IncomeField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  IncomeFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    incomeFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, incomeFB.parameters, param, SqlSyntax.EQuals,
            incomeFB._addedBlocks)
        : setCriteria(pValue, incomeFB.parameters, param, SqlSyntax.NotEQuals,
            incomeFB._addedBlocks);
    _waitingNot = '';
    incomeFB._addedBlocks.needEndBlock[incomeFB._blockIndex] =
        incomeFB._addedBlocks.retVal;
    return incomeFB;
  }

  IncomeFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    incomeFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, incomeFB.parameters, param,
            SqlSyntax.EQualsOrNull, incomeFB._addedBlocks)
        : setCriteria(pValue, incomeFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, incomeFB._addedBlocks);
    _waitingNot = '';
    incomeFB._addedBlocks.needEndBlock[incomeFB._blockIndex] =
        incomeFB._addedBlocks.retVal;
    return incomeFB;
  }

  IncomeFilterBuilder isNull() {
    incomeFB._addedBlocks = setCriteria(
        0,
        incomeFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        incomeFB._addedBlocks);
    _waitingNot = '';
    incomeFB._addedBlocks.needEndBlock[incomeFB._blockIndex] =
        incomeFB._addedBlocks.retVal;
    return incomeFB;
  }

  IncomeFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      incomeFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          incomeFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          incomeFB._addedBlocks);
      _waitingNot = '';
      incomeFB._addedBlocks.needEndBlock[incomeFB._blockIndex] =
          incomeFB._addedBlocks.retVal;
    }
    return incomeFB;
  }

  IncomeFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      incomeFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          incomeFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          incomeFB._addedBlocks);
      _waitingNot = '';
      incomeFB._addedBlocks.needEndBlock[incomeFB._blockIndex] =
          incomeFB._addedBlocks.retVal;
      incomeFB._addedBlocks.needEndBlock[incomeFB._blockIndex] =
          incomeFB._addedBlocks.retVal;
    }
    return incomeFB;
  }

  IncomeFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      incomeFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          incomeFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          incomeFB._addedBlocks);
      _waitingNot = '';
      incomeFB._addedBlocks.needEndBlock[incomeFB._blockIndex] =
          incomeFB._addedBlocks.retVal;
    }
    return incomeFB;
  }

  IncomeFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      incomeFB._addedBlocks = setCriteria(
          pFirst,
          incomeFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          incomeFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        incomeFB._addedBlocks = setCriteria(pFirst, incomeFB.parameters, param,
            SqlSyntax.LessThan, incomeFB._addedBlocks);
      } else {
        incomeFB._addedBlocks = setCriteria(pFirst, incomeFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, incomeFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        incomeFB._addedBlocks = setCriteria(pLast, incomeFB.parameters, param,
            SqlSyntax.GreaterThan, incomeFB._addedBlocks);
      } else {
        incomeFB._addedBlocks = setCriteria(pLast, incomeFB.parameters, param,
            SqlSyntax.LessThanOrEquals, incomeFB._addedBlocks);
      }
    }
    _waitingNot = '';
    incomeFB._addedBlocks.needEndBlock[incomeFB._blockIndex] =
        incomeFB._addedBlocks.retVal;
    return incomeFB;
  }

  IncomeFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    incomeFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, incomeFB.parameters, param, SqlSyntax.GreaterThan,
            incomeFB._addedBlocks)
        : setCriteria(pValue, incomeFB.parameters, param,
            SqlSyntax.LessThanOrEquals, incomeFB._addedBlocks);
    _waitingNot = '';
    incomeFB._addedBlocks.needEndBlock[incomeFB._blockIndex] =
        incomeFB._addedBlocks.retVal;
    return incomeFB;
  }

  IncomeFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    incomeFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, incomeFB.parameters, param, SqlSyntax.LessThan,
            incomeFB._addedBlocks)
        : setCriteria(pValue, incomeFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, incomeFB._addedBlocks);
    _waitingNot = '';
    incomeFB._addedBlocks.needEndBlock[incomeFB._blockIndex] =
        incomeFB._addedBlocks.retVal;
    return incomeFB;
  }

  IncomeFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    incomeFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, incomeFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, incomeFB._addedBlocks)
        : setCriteria(pValue, incomeFB.parameters, param, SqlSyntax.LessThan,
            incomeFB._addedBlocks);
    _waitingNot = '';
    incomeFB._addedBlocks.needEndBlock[incomeFB._blockIndex] =
        incomeFB._addedBlocks.retVal;
    return incomeFB;
  }

  IncomeFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    incomeFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, incomeFB.parameters, param,
            SqlSyntax.LessThanOrEquals, incomeFB._addedBlocks)
        : setCriteria(pValue, incomeFB.parameters, param, SqlSyntax.GreaterThan,
            incomeFB._addedBlocks);
    _waitingNot = '';
    incomeFB._addedBlocks.needEndBlock[incomeFB._blockIndex] =
        incomeFB._addedBlocks.retVal;
    return incomeFB;
  }

  IncomeFilterBuilder inValues(dynamic pValue) {
    incomeFB._addedBlocks = setCriteria(
        pValue,
        incomeFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        incomeFB._addedBlocks);
    _waitingNot = '';
    incomeFB._addedBlocks.needEndBlock[incomeFB._blockIndex] =
        incomeFB._addedBlocks.retVal;
    return incomeFB;
  }
}
// endregion IncomeField

// region IncomeFilterBuilder
class IncomeFilterBuilder extends SearchCriteria {
  IncomeFilterBuilder(Income obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  Income _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  IncomeFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  IncomeFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  IncomeFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  IncomeFilterBuilder where(String whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  IncomeFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  IncomeFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  IncomeFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  IncomeFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  IncomeFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  IncomeFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  IncomeFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  IncomeField setField(IncomeField field, String colName, DbType dbtype) {
    return IncomeField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  IncomeField _income_id;
  IncomeField get income_id {
    return _income_id = setField(_income_id, 'income_id', DbType.integer);
  }

  IncomeField _note;
  IncomeField get note {
    return _note = setField(_note, 'note', DbType.text);
  }

  IncomeField _income_category_id;
  IncomeField get income_category_id {
    return _income_category_id =
        setField(_income_category_id, 'income_category_id', DbType.integer);
  }

  IncomeField _price;
  IncomeField get price {
    return _price = setField(_price, 'price', DbType.integer);
  }

  IncomeField _year;
  IncomeField get year {
    return _year = setField(_year, 'year', DbType.integer);
  }

  IncomeField _month;
  IncomeField get month {
    return _month = setField(_month, 'month', DbType.integer);
  }

  IncomeField _date;
  IncomeField get date {
    return _date = setField(_date, 'date', DbType.integer);
  }

  IncomeField _created_at;
  IncomeField get created_at {
    return _created_at = setField(_created_at, 'created_at', DbType.datetime);
  }

  IncomeField _isDeleted;
  IncomeField get isDeleted {
    return _isDeleted = setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (Income._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<Income> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();

    if (Income._softDeleteActivated && !hardDelete) {
      r = await _obj._mnIncome.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnIncome.delete(qparams);
    }
    return r;
  }

  /// Recover List<Income> bulk by query
  Future<BoolResult> recover() async {
    _getIsDeleted = true;
    _buildParameters();
    print('SQFENTITIY: recover Income bulk invoked');
    return _obj._mnIncome.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'income_id IN (SELECT income_id from income ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnIncome.updateBatch(qparams, values);
  }

  /// This method always returns Income Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Income>
  Future<Income> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnIncome.toList(qparams);
    final data = await objFuture;
    Income obj;
    if (data.isNotEmpty) {
      obj = Income.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('incomecategory.plIncomecategory') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plIncomecategory'))) {
          /*_loadedFields.add('incomecategory.plIncomecategory');*/
          obj.plIncomecategory = obj.plIncomecategory ??
              await obj.getIncomecategory(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [Income]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) incomeCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final incomesFuture = await _obj._mnIncome.toList(qparams);
    final int count = incomesFuture[0]['CNT'] as int;
    if (incomeCount != null) {
      incomeCount(count);
    }
    return count;
  }

  /// This method returns List<Income> [Income]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Income>
  Future<List<Income>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<Income> incomesData = await Income.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return incomesData;
  }

  /// This method returns Json String [Income]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Income]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Income]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnIncome.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Income]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `income_id` FROM income WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> income_idData = <int>[];
    qparams.selectColumns = ['income_id'];
    final income_idFuture = await _obj._mnIncome.toList(qparams);

    final int count = income_idFuture.length;
    for (int i = 0; i < count; i++) {
      income_idData.add(income_idFuture[i]['income_id'] as int);
    }
    return income_idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Income]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnIncome.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await Income.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnIncome.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion IncomeFilterBuilder

// region IncomeFields
class IncomeFields {
  static TableField _fIncome_id;
  static TableField get income_id {
    return _fIncome_id = _fIncome_id ??
        SqlSyntax.setField(_fIncome_id, 'income_id', DbType.integer);
  }

  static TableField _fNote;
  static TableField get note {
    return _fNote = _fNote ?? SqlSyntax.setField(_fNote, 'note', DbType.text);
  }

  static TableField _fIncome_category_id;
  static TableField get income_category_id {
    return _fIncome_category_id = _fIncome_category_id ??
        SqlSyntax.setField(
            _fIncome_category_id, 'income_category_id', DbType.integer);
  }

  static TableField _fPrice;
  static TableField get price {
    return _fPrice =
        _fPrice ?? SqlSyntax.setField(_fPrice, 'price', DbType.integer);
  }

  static TableField _fYear;
  static TableField get year {
    return _fYear =
        _fYear ?? SqlSyntax.setField(_fYear, 'year', DbType.integer);
  }

  static TableField _fMonth;
  static TableField get month {
    return _fMonth =
        _fMonth ?? SqlSyntax.setField(_fMonth, 'month', DbType.integer);
  }

  static TableField _fDate;
  static TableField get date {
    return _fDate =
        _fDate ?? SqlSyntax.setField(_fDate, 'date', DbType.integer);
  }

  static TableField _fCreated_at;
  static TableField get created_at {
    return _fCreated_at = _fCreated_at ??
        SqlSyntax.setField(_fCreated_at, 'created_at', DbType.datetime);
  }

  static TableField _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion IncomeFields

//region IncomeManager
class IncomeManager extends SqfEntityProvider {
  IncomeManager()
      : super(DbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'income';
  static final List<String> _primaryKeyList = ['income_id'];
  static final String _whereStr = 'income_id=?';
}

//endregion IncomeManager
// region Expensecategory
class Expensecategory {
  Expensecategory(
      {this.expense_category_id,
      this.name,
      this.budget,
      this.priority,
      this.icon_id,
      this.created_at,
      this.isDeleted}) {
    _setDefaultValues();
  }
  Expensecategory.withFields(this.name, this.budget, this.priority,
      this.icon_id, this.created_at, this.isDeleted) {
    _setDefaultValues();
  }
  Expensecategory.withId(this.expense_category_id, this.name, this.budget,
      this.priority, this.icon_id, this.created_at, this.isDeleted) {
    _setDefaultValues();
  }
  Expensecategory.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    expense_category_id = int.tryParse(o['expense_category_id'].toString());
    if (o['name'] != null) {
      name = o['name'] as String;
    }
    if (o['budget'] != null) {
      budget = int.tryParse(o['budget'].toString());
    }
    if (o['priority'] != null) {
      priority = int.tryParse(o['priority'].toString());
    }
    icon_id = int.tryParse(o['icon_id'].toString());

    if (o['created_at'] != null) {
      created_at = int.tryParse(o['created_at'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['created_at'].toString()))
          : DateTime.tryParse(o['created_at'].toString());
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;

    // RELATIONSHIPS FromMAP
    plIcon = o['icon'] != null
        ? Icon.fromMap(o['icon'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (Expensecategory)
  int expense_category_id;
  String name;
  int budget;
  int priority;
  int icon_id;
  DateTime created_at;
  bool isDeleted;

  BoolResult saveResult;
  // end FIELDS (Expensecategory)

// RELATIONSHIPS (Expensecategory)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plIcon', 'plField2'..]) or so on..
  Icon plIcon;

  /// get Icon By Icon_id
  Future<Icon> getIcon(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await Icon()
        .getById(icon_id, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Expensecategory)

// COLLECTIONS & VIRTUALS (Expensecategory)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plExpenses', 'plField2'..]) or so on..
  List<Expense> plExpenses;

  /// get Expense(s) filtered by expense_category_id=expense_category_id
  ExpenseFilterBuilder getExpenses(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (expense_category_id == null) {
      return null;
    }
    return Expense()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .expense_category_id
        .equals(expense_category_id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Expensecategory)

  static const bool _softDeleteActivated = true;
  ExpensecategoryManager __mnExpensecategory;

  ExpensecategoryManager get _mnExpensecategory {
    return __mnExpensecategory =
        __mnExpensecategory ?? ExpensecategoryManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (expense_category_id != null) {
      map['expense_category_id'] = expense_category_id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (budget != null) {
      map['budget'] = budget;
    }

    if (priority != null) {
      map['priority'] = priority;
    }

    if (icon_id != null) {
      map['icon_id'] = forView ? plIcon.name : icon_id;
    }

    if (created_at != null) {
      map['created_at'] = forJson
          ? created_at.toString()
          : forQuery
              ? created_at.millisecondsSinceEpoch
              : created_at;
    }

    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted ? 1 : 0) : isDeleted;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (expense_category_id != null) {
      map['expense_category_id'] = expense_category_id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (budget != null) {
      map['budget'] = budget;
    }

    if (priority != null) {
      map['priority'] = priority;
    }

    if (icon_id != null) {
      map['icon_id'] = forView ? plIcon.name : icon_id;
    }

    if (created_at != null) {
      map['created_at'] = forJson
          ? created_at.toString()
          : forQuery
              ? created_at.millisecondsSinceEpoch
              : created_at;
    }

    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted ? 1 : 0) : isDeleted;
    }

// COLLECTIONS (Expensecategory)
    if (!forQuery) {
      map['Expenses'] = await getExpenses().toMapList();
    }
// END COLLECTIONS (Expensecategory)

    return map;
  }

  /// This method returns Json String [Expensecategory]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Expensecategory]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      name,
      budget,
      priority,
      icon_id,
      created_at != null ? created_at.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      expense_category_id,
      name,
      budget,
      priority,
      icon_id,
      created_at != null ? created_at.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  static Future<List<Expensecategory>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR Expensecategory.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<Expensecategory>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Expensecategory>[];
    try {
      objList = list
          .map((expensecategory) =>
              Expensecategory.fromMap(expensecategory as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR Expensecategory.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Expensecategory>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<Expensecategory> objList = <Expensecategory>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Expensecategory.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('expensecategory.plExpenses') && */ (preloadFields ==
                null ||
            preloadFields.contains('plExpenses'))) {
          /*_loadedFields.add('expensecategory.plExpenses'); */
          obj.plExpenses = obj.plExpenses ??
              await obj.getExpenses().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('icon.plIcon') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plIcon'))) {
          /*_loadedFields.add('icon.plIcon');*/
          obj.plIcon = obj.plIcon ??
              await obj.getIcon(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Expensecategory by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int expense_category_id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns Expensecategory if exist, otherwise returns null
  Future<Expensecategory> getById(int expense_category_id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (expense_category_id == null) {
      return null;
    }
    Expensecategory obj;
    final data = await _mnExpensecategory.getById([expense_category_id]);
    if (data.length != 0) {
      obj = Expensecategory.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('expensecategory.plExpenses') && */ (preloadFields ==
                null ||
            preloadFields.contains('plExpenses'))) {
          /*_loadedFields.add('expensecategory.plExpenses'); */
          obj.plExpenses = obj.plExpenses ??
              await obj.getExpenses().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('icon.plIcon') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plIcon'))) {
          /*_loadedFields.add('icon.plIcon');*/
          obj.plIcon = obj.plIcon ??
              await obj.getIcon(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Expensecategory) object. If the expense_category_id field is null, saves as a new record and returns new expense_category_id, if expense_category_id is not null then updates record

  /// <returns>Returns expense_category_id
  Future<int> save() async {
    if (expense_category_id == null || expense_category_id == 0) {
      expense_category_id = await _mnExpensecategory.insert(this);
    } else {
      // expense_category_id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnExpensecategory.update(this);
    }

    return expense_category_id;
  }

  /// saveAs Expensecategory. Returns a new Primary Key value of Expensecategory

  /// <returns>Returns a new Primary Key value of Expensecategory
  Future<int> saveAs() async {
    expense_category_id = null;

    return save();
  }

  /// saveAll method saves the sent List<Expensecategory> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<Expensecategory> expensecategories) async {
    // final results = _mnExpensecategory.saveAll('INSERT OR REPLACE INTO expensecategory (expense_category_id,name, budget, priority, icon_id, created_at,isDeleted)  VALUES (?,?,?,?,?,?,?)',expensecategories);
    // return results; removed in sqfentity_gen 1.3.0+6
    await DbModel().batchStart();
    for (final obj in expensecategories) {
      await obj.save();
    }
    //    return DbModel().batchCommit();
    final result = await DbModel().batchCommit();
    for (int i = 0; i < expensecategories.length; i++) {
      if (expensecategories[i].expense_category_id == null) {
        expensecategories[i].expense_category_id = result[i] as int;
      }
    }

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns expense_category_id
  Future<int> upsert() async {
    try {
      if (await _mnExpensecategory.rawInsert(
              'INSERT OR REPLACE INTO expensecategory (expense_category_id,name, budget, priority, icon_id, created_at,isDeleted)  VALUES (?,?,?,?,?,?,?)',
              [
                expense_category_id,
                name,
                budget,
                priority,
                icon_id,
                created_at != null ? created_at.millisecondsSinceEpoch : null,
                isDeleted
              ]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Expensecategory expense_category_id=$expense_category_id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'Expensecategory expense_category_id=$expense_category_id did not update');
      }
      return expense_category_id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Expensecategory Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<Expensecategory>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(
      List<Expensecategory> expensecategories) async {
    final results = await _mnExpensecategory.rawInsertAll(
        'INSERT OR REPLACE INTO expensecategory (expense_category_id,name, budget, priority, icon_id, created_at,isDeleted)  VALUES (?,?,?,?,?,?,?)',
        expensecategories);
    return results;
  }

  /// Deletes Expensecategory

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print(
        'SQFENTITIY: delete Expensecategory invoked (expense_category_id=$expense_category_id)');
    if (await Expense()
            .select()
            .expense_category_id
            .equals(expense_category_id)
            .and
            .toCount() >
        0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Expense.expense_category_id)');
    }
    if (!_softDeleteActivated || hardDelete || isDeleted) {
      return _mnExpensecategory.delete(QueryParams(
          whereString: 'expense_category_id=?',
          whereArguments: [expense_category_id]));
    } else {
      return _mnExpensecategory.updateBatch(
          QueryParams(
              whereString: 'expense_category_id=?',
              whereArguments: [expense_category_id]),
          {'isDeleted': 1});
    }
  }

  /// Recover Expensecategory>

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    print(
        'SQFENTITIY: recover Expensecategory invoked (expense_category_id=$expense_category_id)');
    {
      return _mnExpensecategory.updateBatch(
          QueryParams(
              whereString: 'expense_category_id=?',
              whereArguments: [expense_category_id]),
          {'isDeleted': 0});
    }
  }

  ExpensecategoryFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return ExpensecategoryFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  ExpensecategoryFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return ExpensecategoryFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isDeleted = isDeleted ?? false;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion expensecategory

// region ExpensecategoryField
class ExpensecategoryField extends SearchCriteria {
  ExpensecategoryField(this.expensecategoryFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  ExpensecategoryFilterBuilder expensecategoryFB;

  ExpensecategoryField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  ExpensecategoryFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    expensecategoryFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, expensecategoryFB.parameters, param,
            SqlSyntax.EQuals, expensecategoryFB._addedBlocks)
        : setCriteria(pValue, expensecategoryFB.parameters, param,
            SqlSyntax.NotEQuals, expensecategoryFB._addedBlocks);
    _waitingNot = '';
    expensecategoryFB._addedBlocks.needEndBlock[expensecategoryFB._blockIndex] =
        expensecategoryFB._addedBlocks.retVal;
    return expensecategoryFB;
  }

  ExpensecategoryFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    expensecategoryFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, expensecategoryFB.parameters, param,
            SqlSyntax.EQualsOrNull, expensecategoryFB._addedBlocks)
        : setCriteria(pValue, expensecategoryFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, expensecategoryFB._addedBlocks);
    _waitingNot = '';
    expensecategoryFB._addedBlocks.needEndBlock[expensecategoryFB._blockIndex] =
        expensecategoryFB._addedBlocks.retVal;
    return expensecategoryFB;
  }

  ExpensecategoryFilterBuilder isNull() {
    expensecategoryFB._addedBlocks = setCriteria(
        0,
        expensecategoryFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        expensecategoryFB._addedBlocks);
    _waitingNot = '';
    expensecategoryFB._addedBlocks.needEndBlock[expensecategoryFB._blockIndex] =
        expensecategoryFB._addedBlocks.retVal;
    return expensecategoryFB;
  }

  ExpensecategoryFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      expensecategoryFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          expensecategoryFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          expensecategoryFB._addedBlocks);
      _waitingNot = '';
      expensecategoryFB
              ._addedBlocks.needEndBlock[expensecategoryFB._blockIndex] =
          expensecategoryFB._addedBlocks.retVal;
    }
    return expensecategoryFB;
  }

  ExpensecategoryFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      expensecategoryFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          expensecategoryFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          expensecategoryFB._addedBlocks);
      _waitingNot = '';
      expensecategoryFB
              ._addedBlocks.needEndBlock[expensecategoryFB._blockIndex] =
          expensecategoryFB._addedBlocks.retVal;
      expensecategoryFB
              ._addedBlocks.needEndBlock[expensecategoryFB._blockIndex] =
          expensecategoryFB._addedBlocks.retVal;
    }
    return expensecategoryFB;
  }

  ExpensecategoryFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      expensecategoryFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          expensecategoryFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          expensecategoryFB._addedBlocks);
      _waitingNot = '';
      expensecategoryFB
              ._addedBlocks.needEndBlock[expensecategoryFB._blockIndex] =
          expensecategoryFB._addedBlocks.retVal;
    }
    return expensecategoryFB;
  }

  ExpensecategoryFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      expensecategoryFB._addedBlocks = setCriteria(
          pFirst,
          expensecategoryFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          expensecategoryFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        expensecategoryFB._addedBlocks = setCriteria(
            pFirst,
            expensecategoryFB.parameters,
            param,
            SqlSyntax.LessThan,
            expensecategoryFB._addedBlocks);
      } else {
        expensecategoryFB._addedBlocks = setCriteria(
            pFirst,
            expensecategoryFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            expensecategoryFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        expensecategoryFB._addedBlocks = setCriteria(
            pLast,
            expensecategoryFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            expensecategoryFB._addedBlocks);
      } else {
        expensecategoryFB._addedBlocks = setCriteria(
            pLast,
            expensecategoryFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            expensecategoryFB._addedBlocks);
      }
    }
    _waitingNot = '';
    expensecategoryFB._addedBlocks.needEndBlock[expensecategoryFB._blockIndex] =
        expensecategoryFB._addedBlocks.retVal;
    return expensecategoryFB;
  }

  ExpensecategoryFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    expensecategoryFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, expensecategoryFB.parameters, param,
            SqlSyntax.GreaterThan, expensecategoryFB._addedBlocks)
        : setCriteria(pValue, expensecategoryFB.parameters, param,
            SqlSyntax.LessThanOrEquals, expensecategoryFB._addedBlocks);
    _waitingNot = '';
    expensecategoryFB._addedBlocks.needEndBlock[expensecategoryFB._blockIndex] =
        expensecategoryFB._addedBlocks.retVal;
    return expensecategoryFB;
  }

  ExpensecategoryFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    expensecategoryFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, expensecategoryFB.parameters, param,
            SqlSyntax.LessThan, expensecategoryFB._addedBlocks)
        : setCriteria(pValue, expensecategoryFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, expensecategoryFB._addedBlocks);
    _waitingNot = '';
    expensecategoryFB._addedBlocks.needEndBlock[expensecategoryFB._blockIndex] =
        expensecategoryFB._addedBlocks.retVal;
    return expensecategoryFB;
  }

  ExpensecategoryFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    expensecategoryFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, expensecategoryFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, expensecategoryFB._addedBlocks)
        : setCriteria(pValue, expensecategoryFB.parameters, param,
            SqlSyntax.LessThan, expensecategoryFB._addedBlocks);
    _waitingNot = '';
    expensecategoryFB._addedBlocks.needEndBlock[expensecategoryFB._blockIndex] =
        expensecategoryFB._addedBlocks.retVal;
    return expensecategoryFB;
  }

  ExpensecategoryFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    expensecategoryFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, expensecategoryFB.parameters, param,
            SqlSyntax.LessThanOrEquals, expensecategoryFB._addedBlocks)
        : setCriteria(pValue, expensecategoryFB.parameters, param,
            SqlSyntax.GreaterThan, expensecategoryFB._addedBlocks);
    _waitingNot = '';
    expensecategoryFB._addedBlocks.needEndBlock[expensecategoryFB._blockIndex] =
        expensecategoryFB._addedBlocks.retVal;
    return expensecategoryFB;
  }

  ExpensecategoryFilterBuilder inValues(dynamic pValue) {
    expensecategoryFB._addedBlocks = setCriteria(
        pValue,
        expensecategoryFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        expensecategoryFB._addedBlocks);
    _waitingNot = '';
    expensecategoryFB._addedBlocks.needEndBlock[expensecategoryFB._blockIndex] =
        expensecategoryFB._addedBlocks.retVal;
    return expensecategoryFB;
  }
}
// endregion ExpensecategoryField

// region ExpensecategoryFilterBuilder
class ExpensecategoryFilterBuilder extends SearchCriteria {
  ExpensecategoryFilterBuilder(Expensecategory obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  Expensecategory _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  ExpensecategoryFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  ExpensecategoryFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  ExpensecategoryFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  ExpensecategoryFilterBuilder where(String whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  ExpensecategoryFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  ExpensecategoryFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  ExpensecategoryFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  ExpensecategoryFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  ExpensecategoryFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  ExpensecategoryFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  ExpensecategoryFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  ExpensecategoryField setField(
      ExpensecategoryField field, String colName, DbType dbtype) {
    return ExpensecategoryField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  ExpensecategoryField _expense_category_id;
  ExpensecategoryField get expense_category_id {
    return _expense_category_id =
        setField(_expense_category_id, 'expense_category_id', DbType.integer);
  }

  ExpensecategoryField _name;
  ExpensecategoryField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  ExpensecategoryField _budget;
  ExpensecategoryField get budget {
    return _budget = setField(_budget, 'budget', DbType.integer);
  }

  ExpensecategoryField _priority;
  ExpensecategoryField get priority {
    return _priority = setField(_priority, 'priority', DbType.integer);
  }

  ExpensecategoryField _icon_id;
  ExpensecategoryField get icon_id {
    return _icon_id = setField(_icon_id, 'icon_id', DbType.integer);
  }

  ExpensecategoryField _created_at;
  ExpensecategoryField get created_at {
    return _created_at = setField(_created_at, 'created_at', DbType.datetime);
  }

  ExpensecategoryField _isDeleted;
  ExpensecategoryField get isDeleted {
    return _isDeleted = setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (Expensecategory._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<Expensecategory> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    // Check sub records where in (Expense) according to DeleteRule.NO_ACTION

    final idListExpenseBYexpense_category_id = toListPrimaryKeySQL(false);
    final resExpenseBYexpense_category_id = await Expense()
        .select()
        .where(
            'expense_category_id IN (${idListExpenseBYexpense_category_id['sql']})',
            parameterValue: idListExpenseBYexpense_category_id['args'])
        .toCount();
    if (resExpenseBYexpense_category_id > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Expense.expense_category_id)');
    }

    if (Expensecategory._softDeleteActivated && !hardDelete) {
      r = await _obj._mnExpensecategory.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnExpensecategory.delete(qparams);
    }
    return r;
  }

  /// Recover List<Expensecategory> bulk by query
  Future<BoolResult> recover() async {
    _getIsDeleted = true;
    _buildParameters();
    print('SQFENTITIY: recover Expensecategory bulk invoked');
    return _obj._mnExpensecategory.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'expense_category_id IN (SELECT expense_category_id from expensecategory ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnExpensecategory.updateBatch(qparams, values);
  }

  /// This method always returns Expensecategory Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Expensecategory>
  Future<Expensecategory> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnExpensecategory.toList(qparams);
    final data = await objFuture;
    Expensecategory obj;
    if (data.isNotEmpty) {
      obj = Expensecategory.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('expensecategory.plExpenses') && */ (preloadFields ==
                null ||
            preloadFields.contains('plExpenses'))) {
          /*_loadedFields.add('expensecategory.plExpenses'); */
          obj.plExpenses = obj.plExpenses ??
              await obj.getExpenses().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('icon.plIcon') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plIcon'))) {
          /*_loadedFields.add('icon.plIcon');*/
          obj.plIcon = obj.plIcon ??
              await obj.getIcon(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [Expensecategory]
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c) expensecategoryCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final expensecategoriesFuture =
        await _obj._mnExpensecategory.toList(qparams);
    final int count = expensecategoriesFuture[0]['CNT'] as int;
    if (expensecategoryCount != null) {
      expensecategoryCount(count);
    }
    return count;
  }

  /// This method returns List<Expensecategory> [Expensecategory]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Expensecategory>
  Future<List<Expensecategory>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<Expensecategory> expensecategoriesData =
        await Expensecategory.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return expensecategoriesData;
  }

  /// This method returns Json String [Expensecategory]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Expensecategory]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Expensecategory]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnExpensecategory.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Expensecategory]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `expense_category_id` FROM expensecategory WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> expense_category_idData = <int>[];
    qparams.selectColumns = ['expense_category_id'];
    final expense_category_idFuture =
        await _obj._mnExpensecategory.toList(qparams);

    final int count = expense_category_idFuture.length;
    for (int i = 0; i < count; i++) {
      expense_category_idData
          .add(expense_category_idFuture[i]['expense_category_id'] as int);
    }
    return expense_category_idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Expensecategory]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnExpensecategory.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await Expensecategory.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnExpensecategory.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ExpensecategoryFilterBuilder

// region ExpensecategoryFields
class ExpensecategoryFields {
  static TableField _fExpense_category_id;
  static TableField get expense_category_id {
    return _fExpense_category_id = _fExpense_category_id ??
        SqlSyntax.setField(
            _fExpense_category_id, 'expense_category_id', DbType.integer);
  }

  static TableField _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField _fBudget;
  static TableField get budget {
    return _fBudget =
        _fBudget ?? SqlSyntax.setField(_fBudget, 'budget', DbType.integer);
  }

  static TableField _fPriority;
  static TableField get priority {
    return _fPriority = _fPriority ??
        SqlSyntax.setField(_fPriority, 'priority', DbType.integer);
  }

  static TableField _fIcon_id;
  static TableField get icon_id {
    return _fIcon_id =
        _fIcon_id ?? SqlSyntax.setField(_fIcon_id, 'icon_id', DbType.integer);
  }

  static TableField _fCreated_at;
  static TableField get created_at {
    return _fCreated_at = _fCreated_at ??
        SqlSyntax.setField(_fCreated_at, 'created_at', DbType.datetime);
  }

  static TableField _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion ExpensecategoryFields

//region ExpensecategoryManager
class ExpensecategoryManager extends SqfEntityProvider {
  ExpensecategoryManager()
      : super(DbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'expensecategory';
  static final List<String> _primaryKeyList = ['expense_category_id'];
  static final String _whereStr = 'expense_category_id=?';
}

//endregion ExpensecategoryManager
// region Incomecategory
class Incomecategory {
  Incomecategory(
      {this.income_category_id,
      this.name,
      this.priority,
      this.icon_id,
      this.created_at,
      this.isDeleted}) {
    _setDefaultValues();
  }
  Incomecategory.withFields(
      this.name, this.priority, this.icon_id, this.created_at, this.isDeleted) {
    _setDefaultValues();
  }
  Incomecategory.withId(this.income_category_id, this.name, this.priority,
      this.icon_id, this.created_at, this.isDeleted) {
    _setDefaultValues();
  }
  Incomecategory.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    income_category_id = int.tryParse(o['income_category_id'].toString());
    if (o['name'] != null) {
      name = o['name'] as String;
    }
    if (o['priority'] != null) {
      priority = int.tryParse(o['priority'].toString());
    }
    icon_id = int.tryParse(o['icon_id'].toString());

    if (o['created_at'] != null) {
      created_at = int.tryParse(o['created_at'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['created_at'].toString()))
          : DateTime.tryParse(o['created_at'].toString());
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;

    // RELATIONSHIPS FromMAP
    plIcon = o['icon'] != null
        ? Icon.fromMap(o['icon'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (Incomecategory)
  int income_category_id;
  String name;
  int priority;
  int icon_id;
  DateTime created_at;
  bool isDeleted;

  BoolResult saveResult;
  // end FIELDS (Incomecategory)

// RELATIONSHIPS (Incomecategory)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plIcon', 'plField2'..]) or so on..
  Icon plIcon;

  /// get Icon By Icon_id
  Future<Icon> getIcon(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await Icon()
        .getById(icon_id, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Incomecategory)

// COLLECTIONS & VIRTUALS (Incomecategory)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plIncomes', 'plField2'..]) or so on..
  List<Income> plIncomes;

  /// get Income(s) filtered by income_category_id=income_category_id
  IncomeFilterBuilder getIncomes(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (income_category_id == null) {
      return null;
    }
    return Income()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .income_category_id
        .equals(income_category_id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Incomecategory)

  static const bool _softDeleteActivated = true;
  IncomecategoryManager __mnIncomecategory;

  IncomecategoryManager get _mnIncomecategory {
    return __mnIncomecategory = __mnIncomecategory ?? IncomecategoryManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (income_category_id != null) {
      map['income_category_id'] = income_category_id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (priority != null) {
      map['priority'] = priority;
    }

    if (icon_id != null) {
      map['icon_id'] = forView ? plIcon.name : icon_id;
    }

    if (created_at != null) {
      map['created_at'] = forJson
          ? created_at.toString()
          : forQuery
              ? created_at.millisecondsSinceEpoch
              : created_at;
    }

    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted ? 1 : 0) : isDeleted;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (income_category_id != null) {
      map['income_category_id'] = income_category_id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (priority != null) {
      map['priority'] = priority;
    }

    if (icon_id != null) {
      map['icon_id'] = forView ? plIcon.name : icon_id;
    }

    if (created_at != null) {
      map['created_at'] = forJson
          ? created_at.toString()
          : forQuery
              ? created_at.millisecondsSinceEpoch
              : created_at;
    }

    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted ? 1 : 0) : isDeleted;
    }

// COLLECTIONS (Incomecategory)
    if (!forQuery) {
      map['Incomes'] = await getIncomes().toMapList();
    }
// END COLLECTIONS (Incomecategory)

    return map;
  }

  /// This method returns Json String [Incomecategory]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Incomecategory]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      name,
      priority,
      icon_id,
      created_at != null ? created_at.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      income_category_id,
      name,
      priority,
      icon_id,
      created_at != null ? created_at.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  static Future<List<Incomecategory>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR Incomecategory.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<Incomecategory>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Incomecategory>[];
    try {
      objList = list
          .map((incomecategory) =>
              Incomecategory.fromMap(incomecategory as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR Incomecategory.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Incomecategory>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<Incomecategory> objList = <Incomecategory>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Incomecategory.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('incomecategory.plIncomes') && */ (preloadFields ==
                null ||
            preloadFields.contains('plIncomes'))) {
          /*_loadedFields.add('incomecategory.plIncomes'); */
          obj.plIncomes = obj.plIncomes ??
              await obj.getIncomes().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('icon.plIcon') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plIcon'))) {
          /*_loadedFields.add('icon.plIcon');*/
          obj.plIcon = obj.plIcon ??
              await obj.getIcon(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Incomecategory by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int income_category_id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns Incomecategory if exist, otherwise returns null
  Future<Incomecategory> getById(int income_category_id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (income_category_id == null) {
      return null;
    }
    Incomecategory obj;
    final data = await _mnIncomecategory.getById([income_category_id]);
    if (data.length != 0) {
      obj = Incomecategory.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('incomecategory.plIncomes') && */ (preloadFields ==
                null ||
            preloadFields.contains('plIncomes'))) {
          /*_loadedFields.add('incomecategory.plIncomes'); */
          obj.plIncomes = obj.plIncomes ??
              await obj.getIncomes().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('icon.plIcon') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plIcon'))) {
          /*_loadedFields.add('icon.plIcon');*/
          obj.plIcon = obj.plIcon ??
              await obj.getIcon(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Incomecategory) object. If the income_category_id field is null, saves as a new record and returns new income_category_id, if income_category_id is not null then updates record

  /// <returns>Returns income_category_id
  Future<int> save() async {
    if (income_category_id == null || income_category_id == 0) {
      income_category_id = await _mnIncomecategory.insert(this);
    } else {
      // income_category_id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnIncomecategory.update(this);
    }

    return income_category_id;
  }

  /// saveAs Incomecategory. Returns a new Primary Key value of Incomecategory

  /// <returns>Returns a new Primary Key value of Incomecategory
  Future<int> saveAs() async {
    income_category_id = null;

    return save();
  }

  /// saveAll method saves the sent List<Incomecategory> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<Incomecategory> incomecategories) async {
    // final results = _mnIncomecategory.saveAll('INSERT OR REPLACE INTO incomecategory (income_category_id,name, priority, icon_id, created_at,isDeleted)  VALUES (?,?,?,?,?,?)',incomecategories);
    // return results; removed in sqfentity_gen 1.3.0+6
    await DbModel().batchStart();
    for (final obj in incomecategories) {
      await obj.save();
    }
    //    return DbModel().batchCommit();
    final result = await DbModel().batchCommit();
    for (int i = 0; i < incomecategories.length; i++) {
      if (incomecategories[i].income_category_id == null) {
        incomecategories[i].income_category_id = result[i] as int;
      }
    }

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns income_category_id
  Future<int> upsert() async {
    try {
      if (await _mnIncomecategory.rawInsert(
              'INSERT OR REPLACE INTO incomecategory (income_category_id,name, priority, icon_id, created_at,isDeleted)  VALUES (?,?,?,?,?,?)',
              [
                income_category_id,
                name,
                priority,
                icon_id,
                created_at != null ? created_at.millisecondsSinceEpoch : null,
                isDeleted
              ]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Incomecategory income_category_id=$income_category_id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'Incomecategory income_category_id=$income_category_id did not update');
      }
      return income_category_id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Incomecategory Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<Incomecategory>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(
      List<Incomecategory> incomecategories) async {
    final results = await _mnIncomecategory.rawInsertAll(
        'INSERT OR REPLACE INTO incomecategory (income_category_id,name, priority, icon_id, created_at,isDeleted)  VALUES (?,?,?,?,?,?)',
        incomecategories);
    return results;
  }

  /// Deletes Incomecategory

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print(
        'SQFENTITIY: delete Incomecategory invoked (income_category_id=$income_category_id)');
    if (await Income()
            .select()
            .income_category_id
            .equals(income_category_id)
            .and
            .toCount() >
        0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Income.income_category_id)');
    }
    if (!_softDeleteActivated || hardDelete || isDeleted) {
      return _mnIncomecategory.delete(QueryParams(
          whereString: 'income_category_id=?',
          whereArguments: [income_category_id]));
    } else {
      return _mnIncomecategory.updateBatch(
          QueryParams(
              whereString: 'income_category_id=?',
              whereArguments: [income_category_id]),
          {'isDeleted': 1});
    }
  }

  /// Recover Incomecategory>

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    print(
        'SQFENTITIY: recover Incomecategory invoked (income_category_id=$income_category_id)');
    {
      return _mnIncomecategory.updateBatch(
          QueryParams(
              whereString: 'income_category_id=?',
              whereArguments: [income_category_id]),
          {'isDeleted': 0});
    }
  }

  IncomecategoryFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return IncomecategoryFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  IncomecategoryFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return IncomecategoryFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isDeleted = isDeleted ?? false;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion incomecategory

// region IncomecategoryField
class IncomecategoryField extends SearchCriteria {
  IncomecategoryField(this.incomecategoryFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  IncomecategoryFilterBuilder incomecategoryFB;

  IncomecategoryField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  IncomecategoryFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    incomecategoryFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, incomecategoryFB.parameters, param,
            SqlSyntax.EQuals, incomecategoryFB._addedBlocks)
        : setCriteria(pValue, incomecategoryFB.parameters, param,
            SqlSyntax.NotEQuals, incomecategoryFB._addedBlocks);
    _waitingNot = '';
    incomecategoryFB._addedBlocks.needEndBlock[incomecategoryFB._blockIndex] =
        incomecategoryFB._addedBlocks.retVal;
    return incomecategoryFB;
  }

  IncomecategoryFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    incomecategoryFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, incomecategoryFB.parameters, param,
            SqlSyntax.EQualsOrNull, incomecategoryFB._addedBlocks)
        : setCriteria(pValue, incomecategoryFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, incomecategoryFB._addedBlocks);
    _waitingNot = '';
    incomecategoryFB._addedBlocks.needEndBlock[incomecategoryFB._blockIndex] =
        incomecategoryFB._addedBlocks.retVal;
    return incomecategoryFB;
  }

  IncomecategoryFilterBuilder isNull() {
    incomecategoryFB._addedBlocks = setCriteria(
        0,
        incomecategoryFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        incomecategoryFB._addedBlocks);
    _waitingNot = '';
    incomecategoryFB._addedBlocks.needEndBlock[incomecategoryFB._blockIndex] =
        incomecategoryFB._addedBlocks.retVal;
    return incomecategoryFB;
  }

  IncomecategoryFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      incomecategoryFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          incomecategoryFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          incomecategoryFB._addedBlocks);
      _waitingNot = '';
      incomecategoryFB._addedBlocks.needEndBlock[incomecategoryFB._blockIndex] =
          incomecategoryFB._addedBlocks.retVal;
    }
    return incomecategoryFB;
  }

  IncomecategoryFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      incomecategoryFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          incomecategoryFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          incomecategoryFB._addedBlocks);
      _waitingNot = '';
      incomecategoryFB._addedBlocks.needEndBlock[incomecategoryFB._blockIndex] =
          incomecategoryFB._addedBlocks.retVal;
      incomecategoryFB._addedBlocks.needEndBlock[incomecategoryFB._blockIndex] =
          incomecategoryFB._addedBlocks.retVal;
    }
    return incomecategoryFB;
  }

  IncomecategoryFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      incomecategoryFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          incomecategoryFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          incomecategoryFB._addedBlocks);
      _waitingNot = '';
      incomecategoryFB._addedBlocks.needEndBlock[incomecategoryFB._blockIndex] =
          incomecategoryFB._addedBlocks.retVal;
    }
    return incomecategoryFB;
  }

  IncomecategoryFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      incomecategoryFB._addedBlocks = setCriteria(
          pFirst,
          incomecategoryFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          incomecategoryFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        incomecategoryFB._addedBlocks = setCriteria(
            pFirst,
            incomecategoryFB.parameters,
            param,
            SqlSyntax.LessThan,
            incomecategoryFB._addedBlocks);
      } else {
        incomecategoryFB._addedBlocks = setCriteria(
            pFirst,
            incomecategoryFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            incomecategoryFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        incomecategoryFB._addedBlocks = setCriteria(
            pLast,
            incomecategoryFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            incomecategoryFB._addedBlocks);
      } else {
        incomecategoryFB._addedBlocks = setCriteria(
            pLast,
            incomecategoryFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            incomecategoryFB._addedBlocks);
      }
    }
    _waitingNot = '';
    incomecategoryFB._addedBlocks.needEndBlock[incomecategoryFB._blockIndex] =
        incomecategoryFB._addedBlocks.retVal;
    return incomecategoryFB;
  }

  IncomecategoryFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    incomecategoryFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, incomecategoryFB.parameters, param,
            SqlSyntax.GreaterThan, incomecategoryFB._addedBlocks)
        : setCriteria(pValue, incomecategoryFB.parameters, param,
            SqlSyntax.LessThanOrEquals, incomecategoryFB._addedBlocks);
    _waitingNot = '';
    incomecategoryFB._addedBlocks.needEndBlock[incomecategoryFB._blockIndex] =
        incomecategoryFB._addedBlocks.retVal;
    return incomecategoryFB;
  }

  IncomecategoryFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    incomecategoryFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, incomecategoryFB.parameters, param,
            SqlSyntax.LessThan, incomecategoryFB._addedBlocks)
        : setCriteria(pValue, incomecategoryFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, incomecategoryFB._addedBlocks);
    _waitingNot = '';
    incomecategoryFB._addedBlocks.needEndBlock[incomecategoryFB._blockIndex] =
        incomecategoryFB._addedBlocks.retVal;
    return incomecategoryFB;
  }

  IncomecategoryFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    incomecategoryFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, incomecategoryFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, incomecategoryFB._addedBlocks)
        : setCriteria(pValue, incomecategoryFB.parameters, param,
            SqlSyntax.LessThan, incomecategoryFB._addedBlocks);
    _waitingNot = '';
    incomecategoryFB._addedBlocks.needEndBlock[incomecategoryFB._blockIndex] =
        incomecategoryFB._addedBlocks.retVal;
    return incomecategoryFB;
  }

  IncomecategoryFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    incomecategoryFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, incomecategoryFB.parameters, param,
            SqlSyntax.LessThanOrEquals, incomecategoryFB._addedBlocks)
        : setCriteria(pValue, incomecategoryFB.parameters, param,
            SqlSyntax.GreaterThan, incomecategoryFB._addedBlocks);
    _waitingNot = '';
    incomecategoryFB._addedBlocks.needEndBlock[incomecategoryFB._blockIndex] =
        incomecategoryFB._addedBlocks.retVal;
    return incomecategoryFB;
  }

  IncomecategoryFilterBuilder inValues(dynamic pValue) {
    incomecategoryFB._addedBlocks = setCriteria(
        pValue,
        incomecategoryFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        incomecategoryFB._addedBlocks);
    _waitingNot = '';
    incomecategoryFB._addedBlocks.needEndBlock[incomecategoryFB._blockIndex] =
        incomecategoryFB._addedBlocks.retVal;
    return incomecategoryFB;
  }
}
// endregion IncomecategoryField

// region IncomecategoryFilterBuilder
class IncomecategoryFilterBuilder extends SearchCriteria {
  IncomecategoryFilterBuilder(Incomecategory obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  Incomecategory _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  IncomecategoryFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  IncomecategoryFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  IncomecategoryFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  IncomecategoryFilterBuilder where(String whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  IncomecategoryFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  IncomecategoryFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  IncomecategoryFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  IncomecategoryFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  IncomecategoryFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  IncomecategoryFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  IncomecategoryFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  IncomecategoryField setField(
      IncomecategoryField field, String colName, DbType dbtype) {
    return IncomecategoryField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  IncomecategoryField _income_category_id;
  IncomecategoryField get income_category_id {
    return _income_category_id =
        setField(_income_category_id, 'income_category_id', DbType.integer);
  }

  IncomecategoryField _name;
  IncomecategoryField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  IncomecategoryField _priority;
  IncomecategoryField get priority {
    return _priority = setField(_priority, 'priority', DbType.integer);
  }

  IncomecategoryField _icon_id;
  IncomecategoryField get icon_id {
    return _icon_id = setField(_icon_id, 'icon_id', DbType.integer);
  }

  IncomecategoryField _created_at;
  IncomecategoryField get created_at {
    return _created_at = setField(_created_at, 'created_at', DbType.datetime);
  }

  IncomecategoryField _isDeleted;
  IncomecategoryField get isDeleted {
    return _isDeleted = setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (Incomecategory._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<Incomecategory> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    // Check sub records where in (Income) according to DeleteRule.NO_ACTION

    final idListIncomeBYincome_category_id = toListPrimaryKeySQL(false);
    final resIncomeBYincome_category_id = await Income()
        .select()
        .where(
            'income_category_id IN (${idListIncomeBYincome_category_id['sql']})',
            parameterValue: idListIncomeBYincome_category_id['args'])
        .toCount();
    if (resIncomeBYincome_category_id > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Income.income_category_id)');
    }

    if (Incomecategory._softDeleteActivated && !hardDelete) {
      r = await _obj._mnIncomecategory.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnIncomecategory.delete(qparams);
    }
    return r;
  }

  /// Recover List<Incomecategory> bulk by query
  Future<BoolResult> recover() async {
    _getIsDeleted = true;
    _buildParameters();
    print('SQFENTITIY: recover Incomecategory bulk invoked');
    return _obj._mnIncomecategory.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'income_category_id IN (SELECT income_category_id from incomecategory ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnIncomecategory.updateBatch(qparams, values);
  }

  /// This method always returns Incomecategory Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Incomecategory>
  Future<Incomecategory> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnIncomecategory.toList(qparams);
    final data = await objFuture;
    Incomecategory obj;
    if (data.isNotEmpty) {
      obj = Incomecategory.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('incomecategory.plIncomes') && */ (preloadFields ==
                null ||
            preloadFields.contains('plIncomes'))) {
          /*_loadedFields.add('incomecategory.plIncomes'); */
          obj.plIncomes = obj.plIncomes ??
              await obj.getIncomes().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('icon.plIcon') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plIcon'))) {
          /*_loadedFields.add('icon.plIcon');*/
          obj.plIcon = obj.plIcon ??
              await obj.getIcon(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [Incomecategory]
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c) incomecategoryCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final incomecategoriesFuture = await _obj._mnIncomecategory.toList(qparams);
    final int count = incomecategoriesFuture[0]['CNT'] as int;
    if (incomecategoryCount != null) {
      incomecategoryCount(count);
    }
    return count;
  }

  /// This method returns List<Incomecategory> [Incomecategory]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Incomecategory>
  Future<List<Incomecategory>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<Incomecategory> incomecategoriesData =
        await Incomecategory.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return incomecategoriesData;
  }

  /// This method returns Json String [Incomecategory]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Incomecategory]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Incomecategory]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnIncomecategory.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Incomecategory]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `income_category_id` FROM incomecategory WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> income_category_idData = <int>[];
    qparams.selectColumns = ['income_category_id'];
    final income_category_idFuture =
        await _obj._mnIncomecategory.toList(qparams);

    final int count = income_category_idFuture.length;
    for (int i = 0; i < count; i++) {
      income_category_idData
          .add(income_category_idFuture[i]['income_category_id'] as int);
    }
    return income_category_idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Incomecategory]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnIncomecategory.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await Incomecategory.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnIncomecategory.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion IncomecategoryFilterBuilder

// region IncomecategoryFields
class IncomecategoryFields {
  static TableField _fIncome_category_id;
  static TableField get income_category_id {
    return _fIncome_category_id = _fIncome_category_id ??
        SqlSyntax.setField(
            _fIncome_category_id, 'income_category_id', DbType.integer);
  }

  static TableField _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField _fPriority;
  static TableField get priority {
    return _fPriority = _fPriority ??
        SqlSyntax.setField(_fPriority, 'priority', DbType.integer);
  }

  static TableField _fIcon_id;
  static TableField get icon_id {
    return _fIcon_id =
        _fIcon_id ?? SqlSyntax.setField(_fIcon_id, 'icon_id', DbType.integer);
  }

  static TableField _fCreated_at;
  static TableField get created_at {
    return _fCreated_at = _fCreated_at ??
        SqlSyntax.setField(_fCreated_at, 'created_at', DbType.datetime);
  }

  static TableField _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion IncomecategoryFields

//region IncomecategoryManager
class IncomecategoryManager extends SqfEntityProvider {
  IncomecategoryManager()
      : super(DbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'incomecategory';
  static final List<String> _primaryKeyList = ['income_category_id'];
  static final String _whereStr = 'income_category_id=?';
}

//endregion IncomecategoryManager
// region Fixedfee
class Fixedfee {
  Fixedfee(
      {this.fixed_fee_id,
      this.name,
      this.price,
      this.payment_cycle_id,
      this.payment_cycle_id,
      this.created_at,
      this.isDeleted}) {
    _setDefaultValues();
  }
  Fixedfee.withFields(this.name, this.price, this.payment_cycle_id,
      this.payment_cycle_id, this.created_at, this.isDeleted) {
    _setDefaultValues();
  }
  Fixedfee.withId(
      this.fixed_fee_id,
      this.name,
      this.price,
      this.payment_cycle_id,
      this.payment_cycle_id,
      this.created_at,
      this.isDeleted) {
    _setDefaultValues();
  }
  Fixedfee.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    fixed_fee_id = int.tryParse(o['fixed_fee_id'].toString());
    if (o['name'] != null) {
      name = o['name'] as String;
    }
    if (o['price'] != null) {
      price = int.tryParse(o['price'].toString());
    }
    if (o['payment_cycle_id'] != null) {
      payment_cycle_id = int.tryParse(o['payment_cycle_id'].toString());
    }
    payment_cycle_id = int.tryParse(o['payment_cycle_id'].toString());

    if (o['created_at'] != null) {
      created_at = int.tryParse(o['created_at'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['created_at'].toString()))
          : DateTime.tryParse(o['created_at'].toString());
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;

    // RELATIONSHIPS FromMAP
    plPaymentcycle = o['paymentcycle'] != null
        ? Paymentcycle.fromMap(o['paymentcycle'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (Fixedfee)
  int fixed_fee_id;
  String name;
  int price;
  int payment_cycle_id;
  int payment_cycle_id;
  DateTime created_at;
  bool isDeleted;

  BoolResult saveResult;
  // end FIELDS (Fixedfee)

// RELATIONSHIPS (Fixedfee)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plPaymentcycle', 'plField2'..]) or so on..
  Paymentcycle plPaymentcycle;

  /// get Paymentcycle By Payment_cycle_id
  Future<Paymentcycle> getPaymentcycle(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await Paymentcycle().getById(payment_cycle_id,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Fixedfee)

  static const bool _softDeleteActivated = true;
  FixedfeeManager __mnFixedfee;

  FixedfeeManager get _mnFixedfee {
    return __mnFixedfee = __mnFixedfee ?? FixedfeeManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (fixed_fee_id != null) {
      map['fixed_fee_id'] = fixed_fee_id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (price != null) {
      map['price'] = price;
    }

    if (payment_cycle_id != null) {
      map['payment_cycle_id'] = payment_cycle_id;
    }

    if (payment_cycle_id != null) {
      map['payment_cycle_id'] =
          forView ? plPaymentcycle.payment_cycle_id : payment_cycle_id;
    }

    if (created_at != null) {
      map['created_at'] = forJson
          ? created_at.toString()
          : forQuery
              ? created_at.millisecondsSinceEpoch
              : created_at;
    }

    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted ? 1 : 0) : isDeleted;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (fixed_fee_id != null) {
      map['fixed_fee_id'] = fixed_fee_id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (price != null) {
      map['price'] = price;
    }

    if (payment_cycle_id != null) {
      map['payment_cycle_id'] = payment_cycle_id;
    }

    if (payment_cycle_id != null) {
      map['payment_cycle_id'] =
          forView ? plPaymentcycle.payment_cycle_id : payment_cycle_id;
    }

    if (created_at != null) {
      map['created_at'] = forJson
          ? created_at.toString()
          : forQuery
              ? created_at.millisecondsSinceEpoch
              : created_at;
    }

    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted ? 1 : 0) : isDeleted;
    }

    return map;
  }

  /// This method returns Json String [Fixedfee]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Fixedfee]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      name,
      price,
      payment_cycle_id,
      payment_cycle_id,
      created_at != null ? created_at.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      fixed_fee_id,
      name,
      price,
      payment_cycle_id,
      payment_cycle_id,
      created_at != null ? created_at.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  static Future<List<Fixedfee>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR Fixedfee.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<Fixedfee>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Fixedfee>[];
    try {
      objList = list
          .map((fixedfee) => Fixedfee.fromMap(fixedfee as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print('SQFENTITY ERROR Fixedfee.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Fixedfee>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<Fixedfee> objList = <Fixedfee>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Fixedfee.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('paymentcycle.plPaymentcycle') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plPaymentcycle'))) {
          /*_loadedFields.add('paymentcycle.plPaymentcycle');*/
          obj.plPaymentcycle = obj.plPaymentcycle ??
              await obj.getPaymentcycle(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Fixedfee by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int fixed_fee_id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns Fixedfee if exist, otherwise returns null
  Future<Fixedfee> getById(int fixed_fee_id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (fixed_fee_id == null) {
      return null;
    }
    Fixedfee obj;
    final data = await _mnFixedfee.getById([fixed_fee_id]);
    if (data.length != 0) {
      obj = Fixedfee.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('paymentcycle.plPaymentcycle') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plPaymentcycle'))) {
          /*_loadedFields.add('paymentcycle.plPaymentcycle');*/
          obj.plPaymentcycle = obj.plPaymentcycle ??
              await obj.getPaymentcycle(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Fixedfee) object. If the fixed_fee_id field is null, saves as a new record and returns new fixed_fee_id, if fixed_fee_id is not null then updates record

  /// <returns>Returns fixed_fee_id
  Future<int> save() async {
    if (fixed_fee_id == null || fixed_fee_id == 0) {
      fixed_fee_id = await _mnFixedfee.insert(this);
    } else {
      // fixed_fee_id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnFixedfee.update(this);
    }

    return fixed_fee_id;
  }

  /// saveAs Fixedfee. Returns a new Primary Key value of Fixedfee

  /// <returns>Returns a new Primary Key value of Fixedfee
  Future<int> saveAs() async {
    fixed_fee_id = null;

    return save();
  }

  /// saveAll method saves the sent List<Fixedfee> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Fixedfee> fixedfees) async {
    // final results = _mnFixedfee.saveAll('INSERT OR REPLACE INTO fixedfee (fixed_fee_id,name, price, payment_cycle_id, payment_cycle_id, created_at,isDeleted)  VALUES (?,?,?,?,?,?,?)',fixedfees);
    // return results; removed in sqfentity_gen 1.3.0+6
    await DbModel().batchStart();
    for (final obj in fixedfees) {
      await obj.save();
    }
    //    return DbModel().batchCommit();
    final result = await DbModel().batchCommit();
    for (int i = 0; i < fixedfees.length; i++) {
      if (fixedfees[i].fixed_fee_id == null) {
        fixedfees[i].fixed_fee_id = result[i] as int;
      }
    }

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns fixed_fee_id
  Future<int> upsert() async {
    try {
      if (await _mnFixedfee.rawInsert(
              'INSERT OR REPLACE INTO fixedfee (fixed_fee_id,name, price, payment_cycle_id, payment_cycle_id, created_at,isDeleted)  VALUES (?,?,?,?,?,?,?)',
              [
                fixed_fee_id,
                name,
                price,
                payment_cycle_id,
                payment_cycle_id,
                created_at != null ? created_at.millisecondsSinceEpoch : null,
                isDeleted
              ]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Fixedfee fixed_fee_id=$fixed_fee_id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Fixedfee fixed_fee_id=$fixed_fee_id did not update');
      }
      return fixed_fee_id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Fixedfee Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<Fixedfee>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<Fixedfee> fixedfees) async {
    final results = await _mnFixedfee.rawInsertAll(
        'INSERT OR REPLACE INTO fixedfee (fixed_fee_id,name, price, payment_cycle_id, payment_cycle_id, created_at,isDeleted)  VALUES (?,?,?,?,?,?,?)',
        fixedfees);
    return results;
  }

  /// Deletes Fixedfee

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete Fixedfee invoked (fixed_fee_id=$fixed_fee_id)');
    if (!_softDeleteActivated || hardDelete || isDeleted) {
      return _mnFixedfee.delete(QueryParams(
          whereString: 'fixed_fee_id=?', whereArguments: [fixed_fee_id]));
    } else {
      return _mnFixedfee.updateBatch(
          QueryParams(
              whereString: 'fixed_fee_id=?', whereArguments: [fixed_fee_id]),
          {'isDeleted': 1});
    }
  }

  /// Recover Fixedfee>

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    print('SQFENTITIY: recover Fixedfee invoked (fixed_fee_id=$fixed_fee_id)');
    {
      return _mnFixedfee.updateBatch(
          QueryParams(
              whereString: 'fixed_fee_id=?', whereArguments: [fixed_fee_id]),
          {'isDeleted': 0});
    }
  }

  FixedfeeFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return FixedfeeFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  FixedfeeFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return FixedfeeFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isDeleted = isDeleted ?? false;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion fixedfee

// region FixedfeeField
class FixedfeeField extends SearchCriteria {
  FixedfeeField(this.fixedfeeFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  FixedfeeFilterBuilder fixedfeeFB;

  FixedfeeField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  FixedfeeFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    fixedfeeFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, fixedfeeFB.parameters, param, SqlSyntax.EQuals,
            fixedfeeFB._addedBlocks)
        : setCriteria(pValue, fixedfeeFB.parameters, param, SqlSyntax.NotEQuals,
            fixedfeeFB._addedBlocks);
    _waitingNot = '';
    fixedfeeFB._addedBlocks.needEndBlock[fixedfeeFB._blockIndex] =
        fixedfeeFB._addedBlocks.retVal;
    return fixedfeeFB;
  }

  FixedfeeFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    fixedfeeFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, fixedfeeFB.parameters, param,
            SqlSyntax.EQualsOrNull, fixedfeeFB._addedBlocks)
        : setCriteria(pValue, fixedfeeFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, fixedfeeFB._addedBlocks);
    _waitingNot = '';
    fixedfeeFB._addedBlocks.needEndBlock[fixedfeeFB._blockIndex] =
        fixedfeeFB._addedBlocks.retVal;
    return fixedfeeFB;
  }

  FixedfeeFilterBuilder isNull() {
    fixedfeeFB._addedBlocks = setCriteria(
        0,
        fixedfeeFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        fixedfeeFB._addedBlocks);
    _waitingNot = '';
    fixedfeeFB._addedBlocks.needEndBlock[fixedfeeFB._blockIndex] =
        fixedfeeFB._addedBlocks.retVal;
    return fixedfeeFB;
  }

  FixedfeeFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      fixedfeeFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          fixedfeeFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          fixedfeeFB._addedBlocks);
      _waitingNot = '';
      fixedfeeFB._addedBlocks.needEndBlock[fixedfeeFB._blockIndex] =
          fixedfeeFB._addedBlocks.retVal;
    }
    return fixedfeeFB;
  }

  FixedfeeFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      fixedfeeFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          fixedfeeFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          fixedfeeFB._addedBlocks);
      _waitingNot = '';
      fixedfeeFB._addedBlocks.needEndBlock[fixedfeeFB._blockIndex] =
          fixedfeeFB._addedBlocks.retVal;
      fixedfeeFB._addedBlocks.needEndBlock[fixedfeeFB._blockIndex] =
          fixedfeeFB._addedBlocks.retVal;
    }
    return fixedfeeFB;
  }

  FixedfeeFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      fixedfeeFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          fixedfeeFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          fixedfeeFB._addedBlocks);
      _waitingNot = '';
      fixedfeeFB._addedBlocks.needEndBlock[fixedfeeFB._blockIndex] =
          fixedfeeFB._addedBlocks.retVal;
    }
    return fixedfeeFB;
  }

  FixedfeeFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      fixedfeeFB._addedBlocks = setCriteria(
          pFirst,
          fixedfeeFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          fixedfeeFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        fixedfeeFB._addedBlocks = setCriteria(pFirst, fixedfeeFB.parameters,
            param, SqlSyntax.LessThan, fixedfeeFB._addedBlocks);
      } else {
        fixedfeeFB._addedBlocks = setCriteria(pFirst, fixedfeeFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, fixedfeeFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        fixedfeeFB._addedBlocks = setCriteria(pLast, fixedfeeFB.parameters,
            param, SqlSyntax.GreaterThan, fixedfeeFB._addedBlocks);
      } else {
        fixedfeeFB._addedBlocks = setCriteria(pLast, fixedfeeFB.parameters,
            param, SqlSyntax.LessThanOrEquals, fixedfeeFB._addedBlocks);
      }
    }
    _waitingNot = '';
    fixedfeeFB._addedBlocks.needEndBlock[fixedfeeFB._blockIndex] =
        fixedfeeFB._addedBlocks.retVal;
    return fixedfeeFB;
  }

  FixedfeeFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    fixedfeeFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, fixedfeeFB.parameters, param,
            SqlSyntax.GreaterThan, fixedfeeFB._addedBlocks)
        : setCriteria(pValue, fixedfeeFB.parameters, param,
            SqlSyntax.LessThanOrEquals, fixedfeeFB._addedBlocks);
    _waitingNot = '';
    fixedfeeFB._addedBlocks.needEndBlock[fixedfeeFB._blockIndex] =
        fixedfeeFB._addedBlocks.retVal;
    return fixedfeeFB;
  }

  FixedfeeFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    fixedfeeFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, fixedfeeFB.parameters, param, SqlSyntax.LessThan,
            fixedfeeFB._addedBlocks)
        : setCriteria(pValue, fixedfeeFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, fixedfeeFB._addedBlocks);
    _waitingNot = '';
    fixedfeeFB._addedBlocks.needEndBlock[fixedfeeFB._blockIndex] =
        fixedfeeFB._addedBlocks.retVal;
    return fixedfeeFB;
  }

  FixedfeeFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    fixedfeeFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, fixedfeeFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, fixedfeeFB._addedBlocks)
        : setCriteria(pValue, fixedfeeFB.parameters, param, SqlSyntax.LessThan,
            fixedfeeFB._addedBlocks);
    _waitingNot = '';
    fixedfeeFB._addedBlocks.needEndBlock[fixedfeeFB._blockIndex] =
        fixedfeeFB._addedBlocks.retVal;
    return fixedfeeFB;
  }

  FixedfeeFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    fixedfeeFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, fixedfeeFB.parameters, param,
            SqlSyntax.LessThanOrEquals, fixedfeeFB._addedBlocks)
        : setCriteria(pValue, fixedfeeFB.parameters, param,
            SqlSyntax.GreaterThan, fixedfeeFB._addedBlocks);
    _waitingNot = '';
    fixedfeeFB._addedBlocks.needEndBlock[fixedfeeFB._blockIndex] =
        fixedfeeFB._addedBlocks.retVal;
    return fixedfeeFB;
  }

  FixedfeeFilterBuilder inValues(dynamic pValue) {
    fixedfeeFB._addedBlocks = setCriteria(
        pValue,
        fixedfeeFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        fixedfeeFB._addedBlocks);
    _waitingNot = '';
    fixedfeeFB._addedBlocks.needEndBlock[fixedfeeFB._blockIndex] =
        fixedfeeFB._addedBlocks.retVal;
    return fixedfeeFB;
  }
}
// endregion FixedfeeField

// region FixedfeeFilterBuilder
class FixedfeeFilterBuilder extends SearchCriteria {
  FixedfeeFilterBuilder(Fixedfee obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  Fixedfee _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  FixedfeeFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  FixedfeeFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  FixedfeeFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  FixedfeeFilterBuilder where(String whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  FixedfeeFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  FixedfeeFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  FixedfeeFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  FixedfeeFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  FixedfeeFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  FixedfeeFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  FixedfeeFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  FixedfeeField setField(FixedfeeField field, String colName, DbType dbtype) {
    return FixedfeeField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  FixedfeeField _fixed_fee_id;
  FixedfeeField get fixed_fee_id {
    return _fixed_fee_id =
        setField(_fixed_fee_id, 'fixed_fee_id', DbType.integer);
  }

  FixedfeeField _name;
  FixedfeeField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  FixedfeeField _price;
  FixedfeeField get price {
    return _price = setField(_price, 'price', DbType.integer);
  }

  FixedfeeField _payment_cycle_id;
  FixedfeeField get payment_cycle_id {
    return _payment_cycle_id =
        setField(_payment_cycle_id, 'payment_cycle_id', DbType.integer);
  }

  FixedfeeField _payment_cycle_id;
  FixedfeeField get payment_cycle_id {
    return _payment_cycle_id =
        setField(_payment_cycle_id, 'payment_cycle_id', DbType.integer);
  }

  FixedfeeField _created_at;
  FixedfeeField get created_at {
    return _created_at = setField(_created_at, 'created_at', DbType.datetime);
  }

  FixedfeeField _isDeleted;
  FixedfeeField get isDeleted {
    return _isDeleted = setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (Fixedfee._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<Fixedfee> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();

    if (Fixedfee._softDeleteActivated && !hardDelete) {
      r = await _obj._mnFixedfee.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnFixedfee.delete(qparams);
    }
    return r;
  }

  /// Recover List<Fixedfee> bulk by query
  Future<BoolResult> recover() async {
    _getIsDeleted = true;
    _buildParameters();
    print('SQFENTITIY: recover Fixedfee bulk invoked');
    return _obj._mnFixedfee.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'fixed_fee_id IN (SELECT fixed_fee_id from fixedfee ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnFixedfee.updateBatch(qparams, values);
  }

  /// This method always returns Fixedfee Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Fixedfee>
  Future<Fixedfee> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnFixedfee.toList(qparams);
    final data = await objFuture;
    Fixedfee obj;
    if (data.isNotEmpty) {
      obj = Fixedfee.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('paymentcycle.plPaymentcycle') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plPaymentcycle'))) {
          /*_loadedFields.add('paymentcycle.plPaymentcycle');*/
          obj.plPaymentcycle = obj.plPaymentcycle ??
              await obj.getPaymentcycle(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [Fixedfee]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) fixedfeeCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final fixedfeesFuture = await _obj._mnFixedfee.toList(qparams);
    final int count = fixedfeesFuture[0]['CNT'] as int;
    if (fixedfeeCount != null) {
      fixedfeeCount(count);
    }
    return count;
  }

  /// This method returns List<Fixedfee> [Fixedfee]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Fixedfee>
  Future<List<Fixedfee>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<Fixedfee> fixedfeesData = await Fixedfee.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return fixedfeesData;
  }

  /// This method returns Json String [Fixedfee]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Fixedfee]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Fixedfee]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnFixedfee.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Fixedfee]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `fixed_fee_id` FROM fixedfee WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> fixed_fee_idData = <int>[];
    qparams.selectColumns = ['fixed_fee_id'];
    final fixed_fee_idFuture = await _obj._mnFixedfee.toList(qparams);

    final int count = fixed_fee_idFuture.length;
    for (int i = 0; i < count; i++) {
      fixed_fee_idData.add(fixed_fee_idFuture[i]['fixed_fee_id'] as int);
    }
    return fixed_fee_idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Fixedfee]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnFixedfee.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await Fixedfee.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnFixedfee.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion FixedfeeFilterBuilder

// region FixedfeeFields
class FixedfeeFields {
  static TableField _fFixed_fee_id;
  static TableField get fixed_fee_id {
    return _fFixed_fee_id = _fFixed_fee_id ??
        SqlSyntax.setField(_fFixed_fee_id, 'fixed_fee_id', DbType.integer);
  }

  static TableField _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField _fPrice;
  static TableField get price {
    return _fPrice =
        _fPrice ?? SqlSyntax.setField(_fPrice, 'price', DbType.integer);
  }

  static TableField _fPayment_cycle_id;
  static TableField get payment_cycle_id {
    return _fPayment_cycle_id = _fPayment_cycle_id ??
        SqlSyntax.setField(
            _fPayment_cycle_id, 'payment_cycle_id', DbType.integer);
  }

  static TableField _fPayment_cycle_id;
  static TableField get payment_cycle_id {
    return _fPayment_cycle_id = _fPayment_cycle_id ??
        SqlSyntax.setField(
            _fPayment_cycle_id, 'payment_cycle_id', DbType.integer);
  }

  static TableField _fCreated_at;
  static TableField get created_at {
    return _fCreated_at = _fCreated_at ??
        SqlSyntax.setField(_fCreated_at, 'created_at', DbType.datetime);
  }

  static TableField _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion FixedfeeFields

//region FixedfeeManager
class FixedfeeManager extends SqfEntityProvider {
  FixedfeeManager()
      : super(DbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'fixedfee';
  static final List<String> _primaryKeyList = ['fixed_fee_id'];
  static final String _whereStr = 'fixed_fee_id=?';
}

//endregion FixedfeeManager
// region Icon
class Icon {
  Icon({this.icon_id, this.name, this.priority}) {
    _setDefaultValues();
  }
  Icon.withFields(this.name, this.priority) {
    _setDefaultValues();
  }
  Icon.withId(this.icon_id, this.name, this.priority) {
    _setDefaultValues();
  }
  Icon.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    icon_id = int.tryParse(o['icon_id'].toString());
    if (o['name'] != null) {
      name = o['name'] as String;
    }
    if (o['priority'] != null) {
      priority = int.tryParse(o['priority'].toString());
    }
  }
  // FIELDS (Icon)
  int icon_id;
  String name;
  int priority;

  BoolResult saveResult;
  // end FIELDS (Icon)

// COLLECTIONS & VIRTUALS (Icon)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plExpensecategories', 'plField2'..]) or so on..
  List<Expensecategory> plExpensecategories;

  /// get Expensecategory(s) filtered by icon_id=icon_id
  ExpensecategoryFilterBuilder getExpensecategories(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (icon_id == null) {
      return null;
    }
    return Expensecategory()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .icon_id
        .equals(icon_id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plIncomecategories', 'plField2'..]) or so on..
  List<Incomecategory> plIncomecategories;

  /// get Incomecategory(s) filtered by icon_id=icon_id
  IncomecategoryFilterBuilder getIncomecategories(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (icon_id == null) {
      return null;
    }
    return Incomecategory()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .icon_id
        .equals(icon_id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Icon)

  static const bool _softDeleteActivated = false;
  IconManager __mnIcon;

  IconManager get _mnIcon {
    return __mnIcon = __mnIcon ?? IconManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (icon_id != null) {
      map['icon_id'] = icon_id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (priority != null) {
      map['priority'] = priority;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (icon_id != null) {
      map['icon_id'] = icon_id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (priority != null) {
      map['priority'] = priority;
    }

// COLLECTIONS (Icon)
    if (!forQuery) {
      map['Expensecategories'] = await getExpensecategories().toMapList();
    }
    if (!forQuery) {
      map['Incomecategories'] = await getIncomecategories().toMapList();
    }
// END COLLECTIONS (Icon)

    return map;
  }

  /// This method returns Json String [Icon]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Icon]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [name, priority];
  }

  List<dynamic> toArgsWithIds() {
    return [icon_id, name, priority];
  }

  static Future<List<Icon>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print('SQFENTITY ERROR Icon.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<Icon>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Icon>[];
    try {
      objList = list
          .map((icon) => Icon.fromMap(icon as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print('SQFENTITY ERROR Icon.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Icon>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<Icon> objList = <Icon>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Icon.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('icon.plExpensecategories') && */ (preloadFields ==
                null ||
            preloadFields.contains('plExpensecategories'))) {
          /*_loadedFields.add('icon.plExpensecategories'); */
          obj.plExpensecategories = obj.plExpensecategories ??
              await obj.getExpensecategories().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('icon.plIncomecategories') && */ (preloadFields ==
                null ||
            preloadFields.contains('plIncomecategories'))) {
          /*_loadedFields.add('icon.plIncomecategories'); */
          obj.plIncomecategories = obj.plIncomecategories ??
              await obj.getIncomecategories().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Icon by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int icon_id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns Icon if exist, otherwise returns null
  Future<Icon> getById(int icon_id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (icon_id == null) {
      return null;
    }
    Icon obj;
    final data = await _mnIcon.getById([icon_id]);
    if (data.length != 0) {
      obj = Icon.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('icon.plExpensecategories') && */ (preloadFields ==
                null ||
            preloadFields.contains('plExpensecategories'))) {
          /*_loadedFields.add('icon.plExpensecategories'); */
          obj.plExpensecategories = obj.plExpensecategories ??
              await obj.getExpensecategories().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('icon.plIncomecategories') && */ (preloadFields ==
                null ||
            preloadFields.contains('plIncomecategories'))) {
          /*_loadedFields.add('icon.plIncomecategories'); */
          obj.plIncomecategories = obj.plIncomecategories ??
              await obj.getIncomecategories().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Icon) object. If the icon_id field is null, saves as a new record and returns new icon_id, if icon_id is not null then updates record

  /// <returns>Returns icon_id
  Future<int> save() async {
    if (icon_id == null || icon_id == 0) {
      icon_id = await _mnIcon.insert(this);
    } else {
      // icon_id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnIcon.update(this);
    }

    return icon_id;
  }

  /// saveAs Icon. Returns a new Primary Key value of Icon

  /// <returns>Returns a new Primary Key value of Icon
  Future<int> saveAs() async {
    icon_id = null;

    return save();
  }

  /// saveAll method saves the sent List<Icon> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Icon> icons) async {
    // final results = _mnIcon.saveAll('INSERT OR REPLACE INTO icon (icon_id,name, priority)  VALUES (?,?,?)',icons);
    // return results; removed in sqfentity_gen 1.3.0+6
    await DbModel().batchStart();
    for (final obj in icons) {
      await obj.save();
    }
    //    return DbModel().batchCommit();
    final result = await DbModel().batchCommit();
    for (int i = 0; i < icons.length; i++) {
      if (icons[i].icon_id == null) {
        icons[i].icon_id = result[i] as int;
      }
    }

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns icon_id
  Future<int> upsert() async {
    try {
      if (await _mnIcon.rawInsert(
              'INSERT OR REPLACE INTO icon (icon_id,name, priority)  VALUES (?,?,?)',
              [icon_id, name, priority]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Icon icon_id=$icon_id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Icon icon_id=$icon_id did not update');
      }
      return icon_id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Icon Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<Icon>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<Icon> icons) async {
    final results = await _mnIcon.rawInsertAll(
        'INSERT OR REPLACE INTO icon (icon_id,name, priority)  VALUES (?,?,?)',
        icons);
    return results;
  }

  /// Deletes Icon

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete Icon invoked (icon_id=$icon_id)');
    if (await Expensecategory().select().icon_id.equals(icon_id).and.toCount() >
        0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Expensecategory.icon_id)');
    }
    if (await Incomecategory().select().icon_id.equals(icon_id).and.toCount() >
        0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Incomecategory.icon_id)');
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnIcon.delete(
          QueryParams(whereString: 'icon_id=?', whereArguments: [icon_id]));
    } else {
      return _mnIcon.updateBatch(
          QueryParams(whereString: 'icon_id=?', whereArguments: [icon_id]),
          {'isDeleted': 1});
    }
  }

  IconFilterBuilder select({List<String> columnsToSelect, bool getIsDeleted}) {
    return IconFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  IconFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return IconFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion icon

// region IconField
class IconField extends SearchCriteria {
  IconField(this.iconFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  IconFilterBuilder iconFB;

  IconField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  IconFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    iconFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, iconFB.parameters, param, SqlSyntax.EQuals,
            iconFB._addedBlocks)
        : setCriteria(pValue, iconFB.parameters, param, SqlSyntax.NotEQuals,
            iconFB._addedBlocks);
    _waitingNot = '';
    iconFB._addedBlocks.needEndBlock[iconFB._blockIndex] =
        iconFB._addedBlocks.retVal;
    return iconFB;
  }

  IconFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    iconFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, iconFB.parameters, param, SqlSyntax.EQualsOrNull,
            iconFB._addedBlocks)
        : setCriteria(pValue, iconFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, iconFB._addedBlocks);
    _waitingNot = '';
    iconFB._addedBlocks.needEndBlock[iconFB._blockIndex] =
        iconFB._addedBlocks.retVal;
    return iconFB;
  }

  IconFilterBuilder isNull() {
    iconFB._addedBlocks = setCriteria(
        0,
        iconFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        iconFB._addedBlocks);
    _waitingNot = '';
    iconFB._addedBlocks.needEndBlock[iconFB._blockIndex] =
        iconFB._addedBlocks.retVal;
    return iconFB;
  }

  IconFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      iconFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          iconFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          iconFB._addedBlocks);
      _waitingNot = '';
      iconFB._addedBlocks.needEndBlock[iconFB._blockIndex] =
          iconFB._addedBlocks.retVal;
    }
    return iconFB;
  }

  IconFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      iconFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          iconFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          iconFB._addedBlocks);
      _waitingNot = '';
      iconFB._addedBlocks.needEndBlock[iconFB._blockIndex] =
          iconFB._addedBlocks.retVal;
      iconFB._addedBlocks.needEndBlock[iconFB._blockIndex] =
          iconFB._addedBlocks.retVal;
    }
    return iconFB;
  }

  IconFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      iconFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          iconFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          iconFB._addedBlocks);
      _waitingNot = '';
      iconFB._addedBlocks.needEndBlock[iconFB._blockIndex] =
          iconFB._addedBlocks.retVal;
    }
    return iconFB;
  }

  IconFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      iconFB._addedBlocks = setCriteria(
          pFirst,
          iconFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          iconFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        iconFB._addedBlocks = setCriteria(pFirst, iconFB.parameters, param,
            SqlSyntax.LessThan, iconFB._addedBlocks);
      } else {
        iconFB._addedBlocks = setCriteria(pFirst, iconFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, iconFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        iconFB._addedBlocks = setCriteria(pLast, iconFB.parameters, param,
            SqlSyntax.GreaterThan, iconFB._addedBlocks);
      } else {
        iconFB._addedBlocks = setCriteria(pLast, iconFB.parameters, param,
            SqlSyntax.LessThanOrEquals, iconFB._addedBlocks);
      }
    }
    _waitingNot = '';
    iconFB._addedBlocks.needEndBlock[iconFB._blockIndex] =
        iconFB._addedBlocks.retVal;
    return iconFB;
  }

  IconFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    iconFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, iconFB.parameters, param, SqlSyntax.GreaterThan,
            iconFB._addedBlocks)
        : setCriteria(pValue, iconFB.parameters, param,
            SqlSyntax.LessThanOrEquals, iconFB._addedBlocks);
    _waitingNot = '';
    iconFB._addedBlocks.needEndBlock[iconFB._blockIndex] =
        iconFB._addedBlocks.retVal;
    return iconFB;
  }

  IconFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    iconFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, iconFB.parameters, param, SqlSyntax.LessThan,
            iconFB._addedBlocks)
        : setCriteria(pValue, iconFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, iconFB._addedBlocks);
    _waitingNot = '';
    iconFB._addedBlocks.needEndBlock[iconFB._blockIndex] =
        iconFB._addedBlocks.retVal;
    return iconFB;
  }

  IconFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    iconFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, iconFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, iconFB._addedBlocks)
        : setCriteria(pValue, iconFB.parameters, param, SqlSyntax.LessThan,
            iconFB._addedBlocks);
    _waitingNot = '';
    iconFB._addedBlocks.needEndBlock[iconFB._blockIndex] =
        iconFB._addedBlocks.retVal;
    return iconFB;
  }

  IconFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    iconFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, iconFB.parameters, param,
            SqlSyntax.LessThanOrEquals, iconFB._addedBlocks)
        : setCriteria(pValue, iconFB.parameters, param, SqlSyntax.GreaterThan,
            iconFB._addedBlocks);
    _waitingNot = '';
    iconFB._addedBlocks.needEndBlock[iconFB._blockIndex] =
        iconFB._addedBlocks.retVal;
    return iconFB;
  }

  IconFilterBuilder inValues(dynamic pValue) {
    iconFB._addedBlocks = setCriteria(
        pValue,
        iconFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        iconFB._addedBlocks);
    _waitingNot = '';
    iconFB._addedBlocks.needEndBlock[iconFB._blockIndex] =
        iconFB._addedBlocks.retVal;
    return iconFB;
  }
}
// endregion IconField

// region IconFilterBuilder
class IconFilterBuilder extends SearchCriteria {
  IconFilterBuilder(Icon obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  Icon _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  IconFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  IconFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  IconFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  IconFilterBuilder where(String whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  IconFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  IconFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  IconFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  IconFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  IconFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  IconFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  IconFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  IconField setField(IconField field, String colName, DbType dbtype) {
    return IconField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  IconField _icon_id;
  IconField get icon_id {
    return _icon_id = setField(_icon_id, 'icon_id', DbType.integer);
  }

  IconField _name;
  IconField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  IconField _priority;
  IconField get priority {
    return _priority = setField(_priority, 'priority', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (Icon._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<Icon> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    // Check sub records where in (Expensecategory) according to DeleteRule.NO_ACTION

    final idListExpensecategoryBYicon_id = toListPrimaryKeySQL(false);
    final resExpensecategoryBYicon_id = await Expensecategory()
        .select()
        .where('icon_id IN (${idListExpensecategoryBYicon_id['sql']})',
            parameterValue: idListExpensecategoryBYicon_id['args'])
        .toCount();
    if (resExpensecategoryBYicon_id > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Expensecategory.icon_id)');
    }
// Check sub records where in (Incomecategory) according to DeleteRule.NO_ACTION

    final idListIncomecategoryBYicon_id = toListPrimaryKeySQL(false);
    final resIncomecategoryBYicon_id = await Incomecategory()
        .select()
        .where('icon_id IN (${idListIncomecategoryBYicon_id['sql']})',
            parameterValue: idListIncomecategoryBYicon_id['args'])
        .toCount();
    if (resIncomecategoryBYicon_id > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Incomecategory.icon_id)');
    }

    if (Icon._softDeleteActivated && !hardDelete) {
      r = await _obj._mnIcon.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnIcon.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'icon_id IN (SELECT icon_id from icon ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnIcon.updateBatch(qparams, values);
  }

  /// This method always returns Icon Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Icon>
  Future<Icon> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnIcon.toList(qparams);
    final data = await objFuture;
    Icon obj;
    if (data.isNotEmpty) {
      obj = Icon.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('icon.plExpensecategories') && */ (preloadFields ==
                null ||
            preloadFields.contains('plExpensecategories'))) {
          /*_loadedFields.add('icon.plExpensecategories'); */
          obj.plExpensecategories = obj.plExpensecategories ??
              await obj.getExpensecategories().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('icon.plIncomecategories') && */ (preloadFields ==
                null ||
            preloadFields.contains('plIncomecategories'))) {
          /*_loadedFields.add('icon.plIncomecategories'); */
          obj.plIncomecategories = obj.plIncomecategories ??
              await obj.getIncomecategories().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [Icon]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) iconCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final iconsFuture = await _obj._mnIcon.toList(qparams);
    final int count = iconsFuture[0]['CNT'] as int;
    if (iconCount != null) {
      iconCount(count);
    }
    return count;
  }

  /// This method returns List<Icon> [Icon]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Icon>
  Future<List<Icon>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<Icon> iconsData = await Icon.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return iconsData;
  }

  /// This method returns Json String [Icon]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Icon]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Icon]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnIcon.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Icon]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `icon_id` FROM icon WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> icon_idData = <int>[];
    qparams.selectColumns = ['icon_id'];
    final icon_idFuture = await _obj._mnIcon.toList(qparams);

    final int count = icon_idFuture.length;
    for (int i = 0; i < count; i++) {
      icon_idData.add(icon_idFuture[i]['icon_id'] as int);
    }
    return icon_idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Icon]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnIcon.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await Icon.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnIcon.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion IconFilterBuilder

// region IconFields
class IconFields {
  static TableField _fIcon_id;
  static TableField get icon_id {
    return _fIcon_id =
        _fIcon_id ?? SqlSyntax.setField(_fIcon_id, 'icon_id', DbType.integer);
  }

  static TableField _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField _fPriority;
  static TableField get priority {
    return _fPriority = _fPriority ??
        SqlSyntax.setField(_fPriority, 'priority', DbType.integer);
  }
}
// endregion IconFields

//region IconManager
class IconManager extends SqfEntityProvider {
  IconManager()
      : super(DbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'icon';
  static final List<String> _primaryKeyList = ['icon_id'];
  static final String _whereStr = 'icon_id=?';
}

//endregion IconManager
// region Paymentcycle
class Paymentcycle {
  Paymentcycle({this.payment_cycle_id, this.month, this.priority}) {
    _setDefaultValues();
  }
  Paymentcycle.withFields(this.month, this.priority) {
    _setDefaultValues();
  }
  Paymentcycle.withId(this.payment_cycle_id, this.month, this.priority) {
    _setDefaultValues();
  }
  Paymentcycle.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    payment_cycle_id = int.tryParse(o['payment_cycle_id'].toString());
    if (o['month'] != null) {
      month = int.tryParse(o['month'].toString());
    }
    if (o['priority'] != null) {
      priority = int.tryParse(o['priority'].toString());
    }
  }
  // FIELDS (Paymentcycle)
  int payment_cycle_id;
  int month;
  int priority;

  BoolResult saveResult;
  // end FIELDS (Paymentcycle)

// COLLECTIONS & VIRTUALS (Paymentcycle)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plFixedfees', 'plField2'..]) or so on..
  List<Fixedfee> plFixedfees;

  /// get Fixedfee(s) filtered by payment_cycle_id=payment_cycle_id
  FixedfeeFilterBuilder getFixedfees(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (payment_cycle_id == null) {
      return null;
    }
    return Fixedfee()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .payment_cycle_id
        .equals(payment_cycle_id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Paymentcycle)

  static const bool _softDeleteActivated = false;
  PaymentcycleManager __mnPaymentcycle;

  PaymentcycleManager get _mnPaymentcycle {
    return __mnPaymentcycle = __mnPaymentcycle ?? PaymentcycleManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (payment_cycle_id != null) {
      map['payment_cycle_id'] = payment_cycle_id;
    }
    if (month != null) {
      map['month'] = month;
    }

    if (priority != null) {
      map['priority'] = priority;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (payment_cycle_id != null) {
      map['payment_cycle_id'] = payment_cycle_id;
    }
    if (month != null) {
      map['month'] = month;
    }

    if (priority != null) {
      map['priority'] = priority;
    }

// COLLECTIONS (Paymentcycle)
    if (!forQuery) {
      map['Fixedfees'] = await getFixedfees().toMapList();
    }
// END COLLECTIONS (Paymentcycle)

    return map;
  }

  /// This method returns Json String [Paymentcycle]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Paymentcycle]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [month, priority];
  }

  List<dynamic> toArgsWithIds() {
    return [payment_cycle_id, month, priority];
  }

  static Future<List<Paymentcycle>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR Paymentcycle.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<Paymentcycle>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Paymentcycle>[];
    try {
      objList = list
          .map((paymentcycle) =>
              Paymentcycle.fromMap(paymentcycle as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR Paymentcycle.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Paymentcycle>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<Paymentcycle> objList = <Paymentcycle>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Paymentcycle.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('paymentcycle.plFixedfees') && */ (preloadFields ==
                null ||
            preloadFields.contains('plFixedfees'))) {
          /*_loadedFields.add('paymentcycle.plFixedfees'); */
          obj.plFixedfees = obj.plFixedfees ??
              await obj.getFixedfees().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Paymentcycle by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int payment_cycle_id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns Paymentcycle if exist, otherwise returns null
  Future<Paymentcycle> getById(int payment_cycle_id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (payment_cycle_id == null) {
      return null;
    }
    Paymentcycle obj;
    final data = await _mnPaymentcycle.getById([payment_cycle_id]);
    if (data.length != 0) {
      obj = Paymentcycle.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('paymentcycle.plFixedfees') && */ (preloadFields ==
                null ||
            preloadFields.contains('plFixedfees'))) {
          /*_loadedFields.add('paymentcycle.plFixedfees'); */
          obj.plFixedfees = obj.plFixedfees ??
              await obj.getFixedfees().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Paymentcycle) object. If the payment_cycle_id field is null, saves as a new record and returns new payment_cycle_id, if payment_cycle_id is not null then updates record

  /// <returns>Returns payment_cycle_id
  Future<int> save() async {
    if (payment_cycle_id == null || payment_cycle_id == 0) {
      payment_cycle_id = await _mnPaymentcycle.insert(this);
    } else {
      // payment_cycle_id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnPaymentcycle.update(this);
    }

    return payment_cycle_id;
  }

  /// saveAs Paymentcycle. Returns a new Primary Key value of Paymentcycle

  /// <returns>Returns a new Primary Key value of Paymentcycle
  Future<int> saveAs() async {
    payment_cycle_id = null;

    return save();
  }

  /// saveAll method saves the sent List<Paymentcycle> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Paymentcycle> paymentcycles) async {
    // final results = _mnPaymentcycle.saveAll('INSERT OR REPLACE INTO paymentcycle (payment_cycle_id,month, priority)  VALUES (?,?,?)',paymentcycles);
    // return results; removed in sqfentity_gen 1.3.0+6
    await DbModel().batchStart();
    for (final obj in paymentcycles) {
      await obj.save();
    }
    //    return DbModel().batchCommit();
    final result = await DbModel().batchCommit();
    for (int i = 0; i < paymentcycles.length; i++) {
      if (paymentcycles[i].payment_cycle_id == null) {
        paymentcycles[i].payment_cycle_id = result[i] as int;
      }
    }

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns payment_cycle_id
  Future<int> upsert() async {
    try {
      if (await _mnPaymentcycle.rawInsert(
              'INSERT OR REPLACE INTO paymentcycle (payment_cycle_id,month, priority)  VALUES (?,?,?)',
              [payment_cycle_id, month, priority]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Paymentcycle payment_cycle_id=$payment_cycle_id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'Paymentcycle payment_cycle_id=$payment_cycle_id did not update');
      }
      return payment_cycle_id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Paymentcycle Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<Paymentcycle>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<Paymentcycle> paymentcycles) async {
    final results = await _mnPaymentcycle.rawInsertAll(
        'INSERT OR REPLACE INTO paymentcycle (payment_cycle_id,month, priority)  VALUES (?,?,?)',
        paymentcycles);
    return results;
  }

  /// Deletes Paymentcycle

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print(
        'SQFENTITIY: delete Paymentcycle invoked (payment_cycle_id=$payment_cycle_id)');
    if (await Fixedfee()
            .select()
            .payment_cycle_id
            .equals(payment_cycle_id)
            .and
            .toCount() >
        0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Fixedfee.payment_cycle_id)');
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnPaymentcycle.delete(QueryParams(
          whereString: 'payment_cycle_id=?',
          whereArguments: [payment_cycle_id]));
    } else {
      return _mnPaymentcycle.updateBatch(
          QueryParams(
              whereString: 'payment_cycle_id=?',
              whereArguments: [payment_cycle_id]),
          {'isDeleted': 1});
    }
  }

  PaymentcycleFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return PaymentcycleFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  PaymentcycleFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return PaymentcycleFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion paymentcycle

// region PaymentcycleField
class PaymentcycleField extends SearchCriteria {
  PaymentcycleField(this.paymentcycleFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  PaymentcycleFilterBuilder paymentcycleFB;

  PaymentcycleField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  PaymentcycleFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    paymentcycleFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, paymentcycleFB.parameters, param,
            SqlSyntax.EQuals, paymentcycleFB._addedBlocks)
        : setCriteria(pValue, paymentcycleFB.parameters, param,
            SqlSyntax.NotEQuals, paymentcycleFB._addedBlocks);
    _waitingNot = '';
    paymentcycleFB._addedBlocks.needEndBlock[paymentcycleFB._blockIndex] =
        paymentcycleFB._addedBlocks.retVal;
    return paymentcycleFB;
  }

  PaymentcycleFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    paymentcycleFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, paymentcycleFB.parameters, param,
            SqlSyntax.EQualsOrNull, paymentcycleFB._addedBlocks)
        : setCriteria(pValue, paymentcycleFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, paymentcycleFB._addedBlocks);
    _waitingNot = '';
    paymentcycleFB._addedBlocks.needEndBlock[paymentcycleFB._blockIndex] =
        paymentcycleFB._addedBlocks.retVal;
    return paymentcycleFB;
  }

  PaymentcycleFilterBuilder isNull() {
    paymentcycleFB._addedBlocks = setCriteria(
        0,
        paymentcycleFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        paymentcycleFB._addedBlocks);
    _waitingNot = '';
    paymentcycleFB._addedBlocks.needEndBlock[paymentcycleFB._blockIndex] =
        paymentcycleFB._addedBlocks.retVal;
    return paymentcycleFB;
  }

  PaymentcycleFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      paymentcycleFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          paymentcycleFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          paymentcycleFB._addedBlocks);
      _waitingNot = '';
      paymentcycleFB._addedBlocks.needEndBlock[paymentcycleFB._blockIndex] =
          paymentcycleFB._addedBlocks.retVal;
    }
    return paymentcycleFB;
  }

  PaymentcycleFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      paymentcycleFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          paymentcycleFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          paymentcycleFB._addedBlocks);
      _waitingNot = '';
      paymentcycleFB._addedBlocks.needEndBlock[paymentcycleFB._blockIndex] =
          paymentcycleFB._addedBlocks.retVal;
      paymentcycleFB._addedBlocks.needEndBlock[paymentcycleFB._blockIndex] =
          paymentcycleFB._addedBlocks.retVal;
    }
    return paymentcycleFB;
  }

  PaymentcycleFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      paymentcycleFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          paymentcycleFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          paymentcycleFB._addedBlocks);
      _waitingNot = '';
      paymentcycleFB._addedBlocks.needEndBlock[paymentcycleFB._blockIndex] =
          paymentcycleFB._addedBlocks.retVal;
    }
    return paymentcycleFB;
  }

  PaymentcycleFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      paymentcycleFB._addedBlocks = setCriteria(
          pFirst,
          paymentcycleFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          paymentcycleFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        paymentcycleFB._addedBlocks = setCriteria(
            pFirst,
            paymentcycleFB.parameters,
            param,
            SqlSyntax.LessThan,
            paymentcycleFB._addedBlocks);
      } else {
        paymentcycleFB._addedBlocks = setCriteria(
            pFirst,
            paymentcycleFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            paymentcycleFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        paymentcycleFB._addedBlocks = setCriteria(
            pLast,
            paymentcycleFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            paymentcycleFB._addedBlocks);
      } else {
        paymentcycleFB._addedBlocks = setCriteria(
            pLast,
            paymentcycleFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            paymentcycleFB._addedBlocks);
      }
    }
    _waitingNot = '';
    paymentcycleFB._addedBlocks.needEndBlock[paymentcycleFB._blockIndex] =
        paymentcycleFB._addedBlocks.retVal;
    return paymentcycleFB;
  }

  PaymentcycleFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    paymentcycleFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, paymentcycleFB.parameters, param,
            SqlSyntax.GreaterThan, paymentcycleFB._addedBlocks)
        : setCriteria(pValue, paymentcycleFB.parameters, param,
            SqlSyntax.LessThanOrEquals, paymentcycleFB._addedBlocks);
    _waitingNot = '';
    paymentcycleFB._addedBlocks.needEndBlock[paymentcycleFB._blockIndex] =
        paymentcycleFB._addedBlocks.retVal;
    return paymentcycleFB;
  }

  PaymentcycleFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    paymentcycleFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, paymentcycleFB.parameters, param,
            SqlSyntax.LessThan, paymentcycleFB._addedBlocks)
        : setCriteria(pValue, paymentcycleFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, paymentcycleFB._addedBlocks);
    _waitingNot = '';
    paymentcycleFB._addedBlocks.needEndBlock[paymentcycleFB._blockIndex] =
        paymentcycleFB._addedBlocks.retVal;
    return paymentcycleFB;
  }

  PaymentcycleFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    paymentcycleFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, paymentcycleFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, paymentcycleFB._addedBlocks)
        : setCriteria(pValue, paymentcycleFB.parameters, param,
            SqlSyntax.LessThan, paymentcycleFB._addedBlocks);
    _waitingNot = '';
    paymentcycleFB._addedBlocks.needEndBlock[paymentcycleFB._blockIndex] =
        paymentcycleFB._addedBlocks.retVal;
    return paymentcycleFB;
  }

  PaymentcycleFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    paymentcycleFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, paymentcycleFB.parameters, param,
            SqlSyntax.LessThanOrEquals, paymentcycleFB._addedBlocks)
        : setCriteria(pValue, paymentcycleFB.parameters, param,
            SqlSyntax.GreaterThan, paymentcycleFB._addedBlocks);
    _waitingNot = '';
    paymentcycleFB._addedBlocks.needEndBlock[paymentcycleFB._blockIndex] =
        paymentcycleFB._addedBlocks.retVal;
    return paymentcycleFB;
  }

  PaymentcycleFilterBuilder inValues(dynamic pValue) {
    paymentcycleFB._addedBlocks = setCriteria(
        pValue,
        paymentcycleFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        paymentcycleFB._addedBlocks);
    _waitingNot = '';
    paymentcycleFB._addedBlocks.needEndBlock[paymentcycleFB._blockIndex] =
        paymentcycleFB._addedBlocks.retVal;
    return paymentcycleFB;
  }
}
// endregion PaymentcycleField

// region PaymentcycleFilterBuilder
class PaymentcycleFilterBuilder extends SearchCriteria {
  PaymentcycleFilterBuilder(Paymentcycle obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  Paymentcycle _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  PaymentcycleFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  PaymentcycleFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  PaymentcycleFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  PaymentcycleFilterBuilder where(String whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  PaymentcycleFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  PaymentcycleFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  PaymentcycleFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  PaymentcycleFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  PaymentcycleFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  PaymentcycleFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  PaymentcycleFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  PaymentcycleField setField(
      PaymentcycleField field, String colName, DbType dbtype) {
    return PaymentcycleField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  PaymentcycleField _payment_cycle_id;
  PaymentcycleField get payment_cycle_id {
    return _payment_cycle_id =
        setField(_payment_cycle_id, 'payment_cycle_id', DbType.integer);
  }

  PaymentcycleField _month;
  PaymentcycleField get month {
    return _month = setField(_month, 'month', DbType.integer);
  }

  PaymentcycleField _priority;
  PaymentcycleField get priority {
    return _priority = setField(_priority, 'priority', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (Paymentcycle._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<Paymentcycle> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    // Check sub records where in (Fixedfee) according to DeleteRule.NO_ACTION

    final idListFixedfeeBYpayment_cycle_id = toListPrimaryKeySQL(false);
    final resFixedfeeBYpayment_cycle_id = await Fixedfee()
        .select()
        .where(
            'payment_cycle_id IN (${idListFixedfeeBYpayment_cycle_id['sql']})',
            parameterValue: idListFixedfeeBYpayment_cycle_id['args'])
        .toCount();
    if (resFixedfeeBYpayment_cycle_id > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Fixedfee.payment_cycle_id)');
    }

    if (Paymentcycle._softDeleteActivated && !hardDelete) {
      r = await _obj._mnPaymentcycle.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnPaymentcycle.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'payment_cycle_id IN (SELECT payment_cycle_id from paymentcycle ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnPaymentcycle.updateBatch(qparams, values);
  }

  /// This method always returns Paymentcycle Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Paymentcycle>
  Future<Paymentcycle> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnPaymentcycle.toList(qparams);
    final data = await objFuture;
    Paymentcycle obj;
    if (data.isNotEmpty) {
      obj = Paymentcycle.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('paymentcycle.plFixedfees') && */ (preloadFields ==
                null ||
            preloadFields.contains('plFixedfees'))) {
          /*_loadedFields.add('paymentcycle.plFixedfees'); */
          obj.plFixedfees = obj.plFixedfees ??
              await obj.getFixedfees().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [Paymentcycle]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) paymentcycleCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final paymentcyclesFuture = await _obj._mnPaymentcycle.toList(qparams);
    final int count = paymentcyclesFuture[0]['CNT'] as int;
    if (paymentcycleCount != null) {
      paymentcycleCount(count);
    }
    return count;
  }

  /// This method returns List<Paymentcycle> [Paymentcycle]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Paymentcycle>
  Future<List<Paymentcycle>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<Paymentcycle> paymentcyclesData = await Paymentcycle.fromMapList(
        data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return paymentcyclesData;
  }

  /// This method returns Json String [Paymentcycle]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Paymentcycle]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Paymentcycle]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnPaymentcycle.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Paymentcycle]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `payment_cycle_id` FROM paymentcycle WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> payment_cycle_idData = <int>[];
    qparams.selectColumns = ['payment_cycle_id'];
    final payment_cycle_idFuture = await _obj._mnPaymentcycle.toList(qparams);

    final int count = payment_cycle_idFuture.length;
    for (int i = 0; i < count; i++) {
      payment_cycle_idData
          .add(payment_cycle_idFuture[i]['payment_cycle_id'] as int);
    }
    return payment_cycle_idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Paymentcycle]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnPaymentcycle.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await Paymentcycle.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnPaymentcycle.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion PaymentcycleFilterBuilder

// region PaymentcycleFields
class PaymentcycleFields {
  static TableField _fPayment_cycle_id;
  static TableField get payment_cycle_id {
    return _fPayment_cycle_id = _fPayment_cycle_id ??
        SqlSyntax.setField(
            _fPayment_cycle_id, 'payment_cycle_id', DbType.integer);
  }

  static TableField _fMonth;
  static TableField get month {
    return _fMonth =
        _fMonth ?? SqlSyntax.setField(_fMonth, 'month', DbType.integer);
  }

  static TableField _fPriority;
  static TableField get priority {
    return _fPriority = _fPriority ??
        SqlSyntax.setField(_fPriority, 'priority', DbType.integer);
  }
}
// endregion PaymentcycleFields

//region PaymentcycleManager
class PaymentcycleManager extends SqfEntityProvider {
  PaymentcycleManager()
      : super(DbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'paymentcycle';
  static final List<String> _primaryKeyList = ['payment_cycle_id'];
  static final String _whereStr = 'payment_cycle_id=?';
}

//endregion PaymentcycleManager
class DbModelSequenceManager extends SqfEntityProvider {
  DbModelSequenceManager() : super(DbModel());
}
// END OF ENTITIES
